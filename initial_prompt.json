[
  {
    "name": "create_dynamic_function",
    "args": {
      "new_function_name": "df_initiate_orb_tool_creation",
      "new_function_description": "This function is called when the Orb of Ingenuity is used. It signals the client to prompt the user for a description of a new tool. It MUST return the exact string 'EVENT:PROMPT_USER_FOR_TOOL_DESCRIPTION'. It should not call any host APIs.",
      "new_function_parameters_schema": {"type": "object", "properties": {}}
    }
  },
  {
    "name": "create_dynamic_function",
    "args": {
      "new_function_name": "df_system_finalize_orb_charging",
      "new_function_description": "SYSTEM FUNCTION: Called after a new tool function is created via Orb of Ingenuity. This function creates the 'charged orb' artifact and gives it to the player. PARAMS: 'soul_id', 'catalyst_artifact_id', 'newly_created_tool_function_name', 'user_provided_description'. \n1. Generate a unique ID for the new charged artifact (e.g., 'charged_orb_xxxx'). \n2. Create a name for the new artifact (e.g., 'Orb: ' + user_provided_description[:25] + '...'). \n3. Create a description (e.g., 'The Orb of Ingenuity, now resonating with power to: ' + user_provided_description). \n4. Call external_apis['host_core_add_artifact_to_gamestate'] with the new ID, name, description, the 'newly_created_tool_function_name' as linked_dynamic_function_name, and properties {'creator_soul_id': params['soul_id'], 'client_interaction_rules': [{'action_name_template': 'Use {artifact_name}', 'requires_landmark_interaction_type_key': 'any', 'passes_target_env_object_id_as_param': 'target_env_object_id_if_applicable', 'is_general_use': true}]}. \n5. Call external_apis['host_give_artifact_to_soul'] with {'soul_id': params['soul_id'], 'artifact_id': <new_charged_artifact_id>}. \n6. Return a JSON string like: {\"message\": \"The Orb of Ingenuity glows! You've learned to manifest '<new_artifact_name>'!\", \"new_artifact_id\": \"<new_charged_artifact_id>\"}. Handle errors by returning JSON with an 'error' key.",
      "new_function_parameters_schema": {
        "type": "object",
        "properties": {
          "soul_id": {"type": "string"}, "catalyst_artifact_id": {"type": "string"},
          "newly_created_tool_function_name": {"type": "string"}, "user_provided_description": {"type": "string"}
        },
        "required": ["soul_id", "catalyst_artifact_id", "newly_created_tool_function_name", "user_provided_description"]
      }
    }
  },
  {
    "name": "create_dynamic_function",
    "args": {
      "new_function_name": "df_interact_with_pedestal",
      "new_function_description": "Player uses an elemental item on a pedestal. Needs 'soul_id', 'artifact_properties' (for element_type), and 'target_env_object_id' (the ID of the pedestal env object) from params. \n1. Get 'element_type' from params['artifact_properties']. \n2. Call external_apis['host_get_environment_object_data'] with {'object_id': params['target_env_object_id']}. Parse JSON and get 'element_required' from its details. \n3. If element_type matches element_required: \n    a. Call external_apis['host_apply_effect_on_environment_object'] with {'object_id': params['target_env_object_id'], 'effect_details': {'is_active': true, 'last_element_placed': element_type, 'client_visual_update': {'new_color_hex': '#33FF33'} }}. \n    b. Call external_apis['host_check_puzzle_condition'] with {'puzzle_id': 'elemental_trial'}. Parse JSON. \n    c. If condition_met is true, call external_apis['host_trigger_world_event'] with {'event_id': 'elemental_trial_success', 'soul_id': params['soul_id']}. Return 'All pedestals active! Trial complete!'. \n    d. Else, return '{element_type} placed on pedestal. It glows!'. \n4. Else (no match), return 'Wrong element.'. \nEnsure all host API results that are JSON strings are parsed with json.loads().",
      "new_function_parameters_schema": {
        "type": "object", "properties": {"target_env_object_id": {"type": "string"}}, "required": ["target_env_object_id"]
      }
    }
  },
  {
    "name": "create_dynamic_function",
    "args": {
      "new_function_name": "df_use_vault_key",
      "new_function_description": "Player uses the Vault Key. Needs 'soul_id', 'location_id', and 'target_env_object_id' from params. \n1. If params['location_id'] is not 'vault_approach', return 'Can only use Vault Key at the Vault Approach.'. \n2. Call external_apis['host_check_puzzle_condition'] with {'puzzle_id': 'vault_access_puzzle'}. Parse JSON. If 'condition_met' is false, return the 'message' from the puzzle check (e.g. 'The chasm blocks the way...'). \n3. If 'condition_met' is true: \n    a. Call external_apis['host_apply_effect_on_environment_object'] with {'object_id': params['target_env_object_id'], 'effect_details': {'is_unlocked': true, 'client_visual_update': {'new_color_hex': '#FFFF99'} }}. (target_env_object_id should be 'vault_keyhole') \n    b. Call external_apis['host_trigger_world_event'] with {'event_id': 'open_vault_door', 'soul_id': params['soul_id']}. \n    c. Return 'Vault key clicks. The door opens!'. \nEnsure all host API results that are JSON strings are parsed with json.loads().",
      "new_function_parameters_schema": {
        "type": "object", 
        "properties": {"target_env_object_id": {"type": "string", "description": "The ID of the keyhole environment object."}},
        "required": ["target_env_object_id"]
      }
    }
  },
  {
    "name": "create_dynamic_function",
    "args": {
      "new_function_name": "df_check_elemental_trial_logic",
      "new_function_description": "Checks the 'elemental_trial' puzzle. Params: 'puzzle_id', 'current_puzzle_state'. \n1. Initialize active_count = 0. \n2. Get 'pedestal_object_ids' from 'current_puzzle_state' (this list should be populated by df_genesis_engine). \n3. For each pedestal_id in the list, call external_apis['host_get_environment_object_data'] to get its state. \n4. If object.details.is_active is true, increment active_count. \n5. Get 'target_pedestals' from 'current_puzzle_state' (default 3). \n6. If active_count >= target_pedestals, return JSON {'condition_met': true, 'message': 'All elemental pedestals are active!'}. \n7. Else, return JSON {'condition_met': false, 'message': '{active_count}/{target_pedestals} pedestals active.'}.",
      "new_function_parameters_schema": {"type": "object", "properties": {"puzzle_id": {"type": "string"}, "current_puzzle_state": {"type": "object"}}, "required": ["puzzle_id", "current_puzzle_state"]}
    }
  },
    {
    "name": "create_dynamic_function",
    "args": {
      "new_function_name": "df_check_vault_access_logic",
      "new_function_description": "Checks the 'vault_access_puzzle'. Params: 'puzzle_id', 'current_puzzle_state'. \n1. Check if any temporary object exists with type 'light_bridge', location_id 'vault_approach', and to_landmark_id 'keyhole_platform_landmark'. (Assumes a host API like 'host_query_temporary_objects' or that temporary objects are listed in game state accessible by another API). \n2. If such a bridge exists and is not expired, return JSON {'condition_met': true, 'message': 'A way to the keyhole is clear!'}. \n3. Else, call external_apis['host_get_environment_object_data'] for 'vault_keyhole'. If its details.is_unlocked is true, return JSON {'condition_met': true, 'message': 'The keyhole is already unlocked.'}. \n4. Else, return JSON {'condition_met': false, 'message': 'The chasm blocks the way to the keyhole.'}.",
      "new_function_parameters_schema": {"type": "object", "properties": {"puzzle_id": {"type": "string"}, "current_puzzle_state": {"type": "object"}}, "required": ["puzzle_id", "current_puzzle_state"]}
    }
  },
  {
    "name": "create_dynamic_function",
    "args": {
      "new_function_name": "df_handle_elemental_trial_success",
      "new_function_description": "Handles 'elemental_trial_success' event. Params: 'event_id', 'soul_id'. \n1. Log 'The Elemental Trial is complete! The sealed door in the Trial Chamber rumbles open.' \n2. Call host_set_puzzle_properties for 'elemental_trial' with {'is_complete': true}. This will implicitly make the exit usable if the client logic for exits respects this puzzle state or if the landmark's state is updated. \n3. As an explicit visual change, call host_set_landmark_visual_config for location 'trial_chamber', landmark 'sealed_door_exit_landmark', with its existing config but merge/update 'material_config': {'base_color_hex': '#77CC77'} to show it's open. (The original description and exit setup on landmark is enough, puzzle state handles usability). \n4. Call host_log_message_to_world: 'A passage to the Vault Approach is now accessible from the Trial Chamber.' \n5. If 'soul_id' is present, call host_give_artifact_to_soul for 'soul_id' and 'orb_01'. \n6. Return 'Elemental Trial complete actions performed.'",
      "new_function_parameters_schema": {"type": "object", "properties": {"event_id": {"type": "string"}, "soul_id": {"type": "string"}}}
    }
  },
  {
    "name": "create_dynamic_function",
    "args": {
      "new_function_name": "df_handle_open_vault_door",
      "new_function_description": "Handles 'open_vault_door' event. Params: 'event_id', 'soul_id'. \n1. Log 'The Vault door rumbles open!'. \n2. Call host_set_puzzle_properties for 'vault_access_puzzle' with {'is_open': true}. \n3. As an explicit visual change for the door itself, call host_set_landmark_visual_config for location 'vault_approach', landmark 'vault_door_main_landmark', with its existing config but merge/update 'material_config': {'base_color_hex': '#90EE90'} to show it's open. \n4. Return 'Vault door opened actions performed.'",
      "new_function_parameters_schema": {"type": "object", "properties": {"event_id": {"type": "string"}, "soul_id": {"type": "string"}}}
    }
  },
  {
    "name": "create_dynamic_function",
    "args": {
      "new_function_name": "df_genesis_engine",
      "new_function_description": "This function creates the entire initial game world by directly calling ONLY host APIs. Remember, the `external_apis` dictionary is directly available in your function's scope; do not attempt to get it from the `params` argument when calling host APIs. It must perform these actions in order, logging major steps using 'host_log_message_to_world':\n\n--- WORLD PROPERTIES ---\n1. Set 'initial_start_location_id': 'trial_chamber'.\n2. Set 'initial_player_artifacts': ['ember_01', 'water_01', 'wind_01', 'key_01'].\n3. Set 'orb_of_ingenuity_artifact_id': 'orb_01'.\n4. Set 'tool_creation_prompt_template': 'Player wants to: \"{description}\". Make a tool. APIs: {api_list}'.\n5. Set 'client_default_settings': {'camera': {'offset_xyz': [0, 2.5, 4.5], 'look_at_offset_y': 1.0}, 'player_controls': {'move_speed': 2.5, 'rotate_speed': 1.5, 'mouse_sensitivity': 0.002}, 'ui': {'log_max_entries': 20}}.\n6. Set 'void_visual_config': {'center_position_xyz': [0,-50,-100], 'ground_type_key': 'none', 'ground_config': {'color_hex': '#100510'}}.\n7. Set 'ui_messages': {'orb_tool_prompt_initiate': 'The Orb of Ingenuity pulses, awaiting your creative command...', 'limbo_void_description': 'Drifting in an unformed expanse, awaiting world genesis...'}.\n8. Set 'ui_special_location_names': {'limbo_void': 'The Void'}.\n\n--- LOCATIONS & VISUALS ---\n9. Log 'Genesis Engine: Creating locations...'.\n10. Add Location 'trial_chamber': Name 'Trial Chamber', Desc 'An ancient chamber with three pedestals... A sealed stone door blocks one exit.'.\n11. Set Visuals for 'trial_chamber': center [0,0,0], ground_type 'flat_plane', ground_config {'size_xz': [20,20], 'color_hex': '#3a3a3a'}.\n12. Add Location 'vault_approach': Name 'Vault Approach', Desc 'A precarious ledge before a massive vault. A chasm separates you from a keyhole platform.'.\n13. Set Visuals for 'vault_approach': center [10,0,0], ground_type 'split_chasm_platforms', ground_config {'player_platform_size_xyz': [5,0.2,4], 'keyhole_platform_size_xyz': [3,0.2,3], 'keyhole_platform_relative_pos_xz': [0,-4], 'color_hex': '#4f4f4f'}.\n\n--- ENVIRONMENT OBJECTS ---\n14. Log 'Genesis Engine: Creating environment objects...'.\n15. Add EnvObject 'pedestal_fire': loc 'trial_chamber', type 'elemental_pedestal', details {'element_required': 'fire', 'is_active': false, 'client_visual_update': {'new_color_hex': '#AA8866'}}.\n16. Add EnvObject 'pedestal_water': loc 'trial_chamber', type 'elemental_pedestal', details {'element_required': 'water', 'is_active': false, 'client_visual_update': {'new_color_hex': '#AA8866'}}.\n17. Add EnvObject 'pedestal_wind': loc 'trial_chamber', type 'elemental_pedestal', details {'element_required': 'wind', 'is_active': false, 'client_visual_update': {'new_color_hex': '#AA8866'}}.\n18. Add EnvObject 'vault_keyhole': loc 'vault_approach', type 'keyhole', details {'is_unlocked': false, 'client_visual_update': {'new_color_hex': '#CCCC88'}}.\n\n--- LANDMARKS & VISUALS ---\n19. Log 'Genesis Engine: Creating landmarks...'.\n20. Landmark 'trial_chamber'/'flame_pedestal_loc': Name 'Flame Pedestal', pos [2,0.25,-2], geom {'type':'sphere', 'radius':0.2}, material {'base_color_hex':'#AA8866'}, target_env_id 'pedestal_fire', interaction_type 'pedestal'.\n21. Landmark 'trial_chamber'/'water_pedestal_loc': Name 'Water Pedestal', pos [0,0.25,-3], geom {'type':'sphere', 'radius':0.2}, material {'base_color_hex':'#AA8866'}, target_env_id 'pedestal_water', interaction_type 'pedestal'.\n22. Landmark 'trial_chamber'/'wind_pedestal_loc': Name 'Wind Pedestal', pos [-2,0.25,-2], geom {'type':'sphere', 'radius':0.2}, material {'base_color_hex':'#AA8866'}, target_env_id 'pedestal_wind', interaction_type 'pedestal'.\n23. Landmark 'trial_chamber'/'sealed_door_exit_landmark': Name 'Sealed Stone Door', pos [0,0.5,-5], geom {'type':'box', 'dimensions':[1,2,0.2]}, material {'base_color_hex':'#BB7777'}, exit_to 'vault_approach', interaction_type 'door'.\n24. Landmark 'vault_approach'/'keyhole_platform_landmark': Name 'Keyhole Platform', pos [0,0.25,-4], geom {'type':'sphere', 'radius':0.3}, material {'base_color_hex':'#CCCC88'}, target_env_id 'vault_keyhole', interaction_type 'keyhole_target'.\n25. Landmark 'vault_approach'/'vault_door_main_landmark': Name 'Massive Vault Door', pos [0,1,-6], geom {'type':'box', 'dimensions':[2,3,0.3]}, material {'base_color_hex':'#AA66DD'}, interaction_type 'door_inert'.\n\n--- PUZZLES & LOGIC REGISTRATION ---\n26. Log 'Genesis Engine: Initializing puzzles and logic...'.\n27. Init Puzzle 'elemental_trial': state {'active_pedestals_count': 0, 'target_pedestals': 3, 'is_complete': false, 'pedestal_object_ids': ['pedestal_fire', 'pedestal_water', 'pedestal_wind']}.\n28. Register Puzzle Check for 'elemental_trial': func 'df_check_elemental_trial_logic'.\n29. Register Event Handler for 'elemental_trial_success': func 'df_handle_elemental_trial_success'.\n30. Init Puzzle 'vault_access_puzzle': state {'keyhole_unlocked': false, 'is_open': false}.\n31. Register Puzzle Check for 'vault_access_puzzle': func 'df_check_vault_access_logic'.\n32. Register Event Handler for 'open_vault_door': func 'df_handle_open_vault_door'.\n\n--- ARTIFACTS & INTERACTION RULES ---\n33. Log 'Genesis Engine: Creating artifacts...'.\n34. Artifact 'ember_01': Name 'Flaming Ember', Desc 'A constantly burning ember.', props {'element_type': 'fire', 'client_interaction_rules': [{'action_name_template': 'Use {artifact_name} on {target_name}', 'requires_landmark_interaction_type_key': 'pedestal', 'passes_target_env_object_id_as_param': 'target_env_object_id'}]}, linked_func 'df_interact_with_pedestal'.\n35. Artifact 'water_01': Name 'Water Droplet', Desc 'A perfect, shimmering droplet.', props {'element_type': 'water', 'client_interaction_rules': [{'action_name_template': 'Use {artifact_name} on {target_name}', 'requires_landmark_interaction_type_key': 'pedestal', 'passes_target_env_object_id_as_param': 'target_env_object_id'}]}, linked_func 'df_interact_with_pedestal'.\n36. Artifact 'wind_01': Name 'Gust of Wind', Desc 'Feels like a captured breeze.', props {'element_type': 'wind', 'client_interaction_rules': [{'action_name_template': 'Use {artifact_name} on {target_name}', 'requires_landmark_interaction_type_key': 'pedestal', 'passes_target_env_object_id_as_param': 'target_env_object_id'}]}, linked_func 'df_interact_with_pedestal'.\n37. Artifact 'key_01': Name 'Vault Key', Desc 'A heavy key...', props {'client_interaction_rules': [{'action_name_template': 'Use {artifact_name} at {target_name}', 'requires_landmark_interaction_type_key': 'keyhole_target', 'passes_target_env_object_id_as_param': 'target_env_object_id'}]}, linked_func 'df_use_vault_key'.\n38. Artifact 'orb_01': Name 'Orb of Ingenuity', Desc 'A crystal orb humming with potential.', props {'client_interaction_rules': [{'action_name_template': 'Use {artifact_name}', 'is_general_use': true}]}, linked_func 'df_initiate_orb_tool_creation'.\n\n39. Log 'Genesis Engine: World structure complete!'.\nReturn 'World Genesis complete via df_genesis_engine!' upon success.",
      "new_function_parameters_schema": {"type": "object", "properties": {}}
    }
  },
  {
    "name": "df_genesis_engine",
    "args": {}
  }
]
