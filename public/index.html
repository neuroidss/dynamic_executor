<!DOCTYPE html>
 <html>
 <head>
     <title>Infinite MMORPG - Orb of Ingenuity Demo</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
     <style>
         body { font-family: sans-serif; display: flex; flex-direction: column; height: 100vh; margin: 0; background-color: #111; color: #eee; overflow: hidden; }
         #game-container { position: relative; flex-grow: 1; width: 100%; height: 100%; }
         #threejs-canvas { display: block; width: 100%; height: 100%; }
         .ui-overlay { position: absolute; left: 0; right: 0; background-color: rgba(0,0,0,0.6); padding: 5px; box-sizing: border-box; }
         #log-area { top: 0; height: 35%; overflow-y: scroll; font-size: 0.8em; border-bottom: 1px solid #444;}
         #log-area p { margin: 2px 0; }
         #status-area { bottom: 25%; height: 20%; overflow-y: auto; font-size: 0.8em; border-top: 1px solid #444; padding: 8px;}
         #action-area { bottom: 0; height: 25%; overflow-y: auto; border-top: 1px solid #444;}
         #action-buttons button { display: block; width: 95%; margin: 3px auto; padding: 8px 10px; font-size: 0.9em; cursor: pointer; background-color: #3a5a97; color: white; border: 1px solid #5c7abd; border-radius: 4px; text-align: left; }
         #action-buttons button:hover { background-color: #4a6ab7; }
         #action-buttons button .desc { font-size: 0.7em; color: #ccc; display: block; margin-top: 2px;}
         #debug-area { position: fixed; top: 40%; right: 5px; background: rgba(0,0,0,0.7); color: lime; font-family: monospace; font-size: 0.6em; max-height: 100px; width:150px; overflow-y: scroll; padding: 3px; opacity: 0.8; z-index: 100; border: 1px solid lime;}
         h3 {margin-top: 0; margin-bottom: 3px; text-align: center; border-bottom: 1px solid #555; padding-bottom: 3px; font-size: 1em;}
     </style>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
     <script src="https://cdn.socket.io/4.8.1/socket.io.min.js" integrity="sha384-mkQ3/7FUtcGyoppY6bz/PORYoGqOl7/aSUMn2ymDOJcapfS6PHqxhRTMh1RR0Q6+" crossorigin="anonymous"></script>
 </head>
 <body>
     <div id="game-container">
         <canvas id="threejs-canvas"></canvas>
         <div id="log-area" class="ui-overlay">
             <h3>World Log</h3>
             <div id="log-content"></div>
         </div>
         <div id="status-area" class="ui-overlay">
              Loading...
         </div>
         <div id="action-area" class="ui-overlay">
             <h3>Inventory Actions</h3>
             <div id="action-buttons"></div>
         </div>
     </div>
      <div id="debug-area">
          <div id="debug-content"></div>
      </div>

     <script>
         const socket = io();

         const logContent = document.getElementById('log-content');
         const statusArea = document.getElementById('status-area');
         const actionButtons = document.getElementById('action-buttons');
         const debugContent = document.getElementById('debug-content');
         const canvas = document.getElementById('threejs-canvas');

         let playerSoulId = null;
         let currentGameState = {};

         // --- Three.js Setup ---
         let scene, camera, renderer, playerAvatar, controls;
         const landmarkObjects = {}; // Store 3D objects for landmarks
         const temporary3DObjects = {}; // Store 3D objects for temporary game objects

         // Define some fixed 3D positions for landmarks within locations (example)
         const landmarkPositions = {
             trial_chamber: {
                 flame_pedestal_loc: new THREE.Vector3(2, 0, -2),
                 water_pedestal_loc: new THREE.Vector3(0, 0, -3),
                 wind_pedestal_loc: new THREE.Vector3(-2, 0, -2),
                 sealed_door_exit: new THREE.Vector3(0, 0.5, -5)
             },
             vault_approach: {
                 keyhole_platform_exit: new THREE.Vector3(0, 0, -4),
                 vault_door_main: new THREE.Vector3(0, 1, -6)
             }
         };
         const locationCenterPositions = {
             trial_chamber: new THREE.Vector3(0,0,0),
             vault_approach: new THREE.Vector3(10,0,0), // Example: different center
             undefined: new THREE.Vector3(0,0,-100) // "The Void"
         }


         function initThree() {
             scene = new THREE.Scene();
             scene.background = new THREE.Color(0x282c34);

             camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
             camera.position.set(0, 2, 5); // Initial camera position

             renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
             renderer.setSize(window.innerWidth, window.innerHeight);

             // Basic Lighting
             const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
             scene.add(ambientLight);
             const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
             directionalLight.position.set(5, 10, 7);
             scene.add(directionalLight);

             // Player Avatar
             const playerGeometry = new THREE.BoxGeometry(0.5, 1, 0.5);
             const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
             playerAvatar = new THREE.Mesh(playerGeometry, playerMaterial);
             playerAvatar.position.y = 0.5; // Stand on the ground
             scene.add(playerAvatar);
             
             // Ground Plane
             const groundGeometry = new THREE.PlaneGeometry(20, 20);
             const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, side: THREE.DoubleSide });
             const ground = new THREE.Mesh(groundGeometry, groundMaterial);
             ground.rotation.x = -Math.PI / 2;
             scene.add(ground);

             // Basic Orbit Controls (Touch/Mouse)
             let isDragging = false;
             let previousMousePosition = { x: 0, y: 0 };

             const onPointerDown = (event) => {
                 isDragging = true;
                 previousMousePosition.x = event.clientX || (event.touches && event.touches[0].clientX);
                 previousMousePosition.y = event.clientY || (event.touches && event.touches[0].clientY);
             };
             const onPointerMove = (event) => {
                 if (!isDragging) return;
                 const clientX = event.clientX || (event.touches && event.touches[0].clientX);
                 const clientY = event.clientY || (event.touches && event.touches[0].clientY);
                 const deltaMove = {
                     x: clientX - previousMousePosition.x,
                     y: clientY - previousMousePosition.y
                 };
                 const rotationSpeed = 0.005;
                 playerAvatar.rotation.y -= deltaMove.x * rotationSpeed; // Example: Rotate avatar or camera
                 camera.position.y -= deltaMove.y * rotationSpeed * 0.5;
                 camera.position.y = Math.max(1, Math.min(camera.position.y, 5)); // Clamp camera height

                 previousMousePosition.x = clientX;
                 previousMousePosition.y = clientY;
             };
             const onPointerUp = () => { isDragging = false; };
             const onWheel = (event) => {
                 camera.position.z += event.deltaY * 0.01;
                 camera.position.z = Math.max(2, Math.min(camera.position.z, 10));
             }

             canvas.addEventListener('pointerdown', onPointerDown, false);
             canvas.addEventListener('pointermove', onPointerMove, false);
             canvas.addEventListener('pointerup', onPointerUp, false);
             canvas.addEventListener('pointerout', onPointerUp, false); // Also stop dragging if pointer leaves canvas
             canvas.addEventListener('wheel', onWheel, false);


             animate();
             window.addEventListener('resize', onWindowResize, false);
         }

         function onWindowResize() {
             camera.aspect = window.innerWidth / window.innerHeight;
             camera.updateProjectionMatrix();
             renderer.setSize(window.innerWidth, window.innerHeight);
         }

         function animate() {
             requestAnimationFrame(animate);
             // Update camera to look at player (or a point in front of player)
             if (playerAvatar) {
                const lookAtOffset = new THREE.Vector3(0, 0.5, -1); // Look slightly in front and up
                const lookAtTarget = playerAvatar.position.clone().add(lookAtOffset.applyQuaternion(playerAvatar.quaternion));
                const cameraOffset = new THREE.Vector3(0, 2, 3); // Camera behind and above
                const cameraTargetPosition = playerAvatar.position.clone().add(cameraOffset.applyQuaternion(playerAvatar.quaternion));
                
                camera.position.lerp(cameraTargetPosition, 0.1);
                camera.lookAt(lookAtTarget);
             }
             renderer.render(scene, camera);
         }
         // --- End Three.js Setup ---

         function addLogMessage(message, type = 'info') {
             const p = document.createElement('p');
             p.textContent = message;
             if (type === 'error') p.style.color = '#ff8c8c';
             if (type === 'success') p.style.color = '#8cff8c';
             if (type === 'event') { p.style.color = '#8cb8ff'; p.style.fontWeight = 'bold';}
             logContent.appendChild(p);
             logContent.scrollTop = logContent.scrollHeight;
         }

         function addDebugMessage(message) {
             const d = document.createElement('div');
             d.textContent = message;
             debugContent.appendChild(d);
             debugContent.scrollTop = debugContent.scrollHeight;
         }
        
         function updateLandmarks3D(locationId, landmarksData) {
            // Clear old landmarks
            for (const key in landmarkObjects) {
                scene.remove(landmarkObjects[key]);
                delete landmarkObjects[key];
            }
            if (!landmarksData || !locationId) return;

            const currentLocLandmarkPositions = landmarkPositions[locationId] || {};
            const locCenter = locationCenterPositions[locationId] || new THREE.Vector3(0,0,0);

            for (const [key, name] of Object.entries(landmarksData)) {
                const pos = currentLocLandmarkPositions[key] ? currentLocLandmarkPositions[key].clone().add(locCenter) : locCenter.clone().add(new THREE.Vector3(Math.random()*4-2, 0.25, Math.random()*4-2)); // Default random if not specified
                const landmarkGeo = new THREE.SphereGeometry(0.2, 16, 16);
                let landmarkMatColor = 0xaaaaaa;
                if (key.includes("pedestal")) landmarkMatColor = 0xccaa88;
                if (key.includes("door")) landmarkMatColor = 0x8888cc;
                const landmarkMat = new THREE.MeshStandardMaterial({ color: landmarkMatColor });
                const landmarkMesh = new THREE.Mesh(landmarkGeo, landmarkMat);
                landmarkMesh.position.copy(pos);
                landmarkMesh.userData = { id: key, name: name, type: 'landmark' }; // For potential raycasting
                scene.add(landmarkMesh);
                landmarkObjects[key] = landmarkMesh;

                // Simple text label (optional, can be performance intensive)
                // const label = createTextSprite(name);
                // label.position.copy(pos).add(new THREE.Vector3(0, 0.5, 0));
                // scene.add(label);
                // landmarkObjects[key + "_label"] = label;
            }
        }
        
        function updateTemporaryObjects3D(tempObjectsData, currentLocationId) {
            // Clear old temporary objects that no longer exist or expired
            for (const objId in temporary3DObjects) {
                if (!tempObjectsData || !tempObjectsData.find(obj => obj.id === objId && obj.location_id === currentLocationId)) {
                    scene.remove(temporary3DObjects[objId]);
                    delete temporary3DObjects[objId];
                }
            }
            if (!tempObjectsData || !currentLocationId) return;

            const locCenter = locationCenterPositions[currentLocationId] || new THREE.Vector3(0,0,0);
            const currentLocLandmarkPositions = landmarkPositions[currentLocationId] || {};

            tempObjectsData.forEach(obj => {
                if (obj.location_id !== currentLocationId || temporary3DObjects[obj.id]) return; // Already exists or wrong location

                if (obj.type === 'light_bridge') {
                    let fromPos = playerAvatar.position.clone(); // Default 'player_current_pos'
                    const toLandmarkKey = obj.to; // e.g., "keyhole_platform_exit"
                    let toPos = currentLocLandmarkPositions[toLandmarkKey] ? currentLocLandmarkPositions[toLandmarkKey].clone().add(locCenter) : locCenter.clone().add(new THREE.Vector3(0,0,-5)); // Default if target landmark unknown

                    const distance = fromPos.distanceTo(toPos);
                    const bridgeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
                    const bridgeGeometry = new THREE.BoxGeometry(0.3, 0.1, distance);
                    const bridgeMesh = new THREE.Mesh(bridgeGeometry, bridgeMaterial);

                    bridgeMesh.position.copy(fromPos).lerp(toPos, 0.5); // Midpoint
                    bridgeMesh.lookAt(toPos);
                    bridgeMesh.position.y = 0.1; // Slightly above ground

                    scene.add(bridgeMesh);
                    temporary3DObjects[obj.id] = bridgeMesh;
                    
                    // Auto-remove visually after duration (crude client-side removal)
                    setTimeout(() => {
                        if (temporary3DObjects[obj.id]) {
                            scene.remove(temporary3DObjects[obj.id]);
                            delete temporary3DObjects[obj.id];
                        }
                    }, obj.duration * 1000);
                }
            });
        }


         function updateStatus(state) {
              if (!state || !state.playerSoul || !state.currentLocation) {
                  statusArea.innerHTML = "Waiting for server data...";
                  return;
              }
              currentGameState = state;

              let statusHTML = `
                  <strong>${state.playerSoul.name}</strong> (ID: ${state.playerSoul.id.substring(0,8)})<br>
                  Location: <strong>${state.currentLocation.name}</strong><br>
                  <em>${state.currentLocation.description}</em><br>
                  Exits: ${Object.entries(state.currentLocation.exits || {}).map(([dir, loc_id]) => `${dir}: ${loc_id}`).join(', ') || 'None'} <br>
                  Landmarks: ${state.currentLocation.landmarks ? Object.keys(state.currentLocation.landmarks).join(', ') : 'None'} <br>
                  Temporary Notes: ${state.currentLocation.temporary_notes || 'None'} <br>
                  Inventory: ${state.inventory ? state.inventory.map(a => a.name).join(', ') : 'Empty'}
              `;
              statusArea.innerHTML = statusHTML;

              // Update 3D elements
              if (playerAvatar) {
                  const currentLocId = state.playerSoul.locationId || 'undefined';
                  playerAvatar.position.copy(locationCenterPositions[currentLocId] || new THREE.Vector3(0,0.5,0));
                  updateLandmarks3D(currentLocId, state.currentLocation.landmarks);
              }
              updateTemporaryObjects3D(state.activeTemporaryObjects, state.playerSoul.locationId);

         }

         function updateLog(logEntries) {
              if (!logEntries) return;
              logContent.innerHTML = '';
              logEntries.forEach(msg => addLogMessage(msg));
         }

         function renderActions(actions) {
             actionButtons.innerHTML = '';
             if (!actions || actions.length === 0) {
                 actionButtons.innerHTML = '<p>No actions available.</p>';
                 return;
             }

             actions.forEach(actionArtifact => {
                 const button = document.createElement('button');
                 button.dataset.artifactId = actionArtifact.id;
                 button.innerHTML = `${actionArtifact.name} <span class="desc">${actionArtifact.description || `(Use ${actionArtifact.name})`}</span>`;

                 button.onclick = () => {
                     addDebugMessage(`Clicked action: ${actionArtifact.name} (ID: ${actionArtifact.id}, Func: ${actionArtifact.toolName || 'N/A'})`);
                     let args = {};
                     if (actionArtifact.toolName === 'df_interact_with_pedestal') {
                         const targetPedestal = prompt("Which pedestal ID? (e.g., pedestal_fire, pedestal_water, pedestal_wind)");
                         if (!targetPedestal) return;
                         args.target_pedestal_id = targetPedestal.trim();
                     }
                     // For df_system_finalize_orb_charging, catalyst_artifact_id, new_tool_function_name, user_desc are needed.
                     // This is now handled server-side after 'create_dynamic_function' and before 'df_system_finalize_orb_charging'
                     socket.emit('performAction', { artifactId: actionArtifact.id, args: args });
                 };
                 actionButtons.appendChild(button);
             });
         }

         socket.on('connect', () => {
             addLogMessage('Connected to Orb of Ingenuity!', 'success');
             addDebugMessage(`Socket ID: ${socket.id}`);
             initThree(); // Initialize Three.js scene on connect
         });

         socket.on('disconnect', () => {
             addLogMessage('Disconnected.', 'error');
         });

          socket.on('assignSoulId', (id) => {
              playerSoulId = id;
              addDebugMessage(`Player Soul ID: ${playerSoulId}`);
              socket.emit('requestState');
          });

         socket.on('gameStateUpdate', (state) => {
              addDebugMessage('Received gameStateUpdate');
              if (state.error){
                  addLogMessage(`Server Error: ${state.error}`, 'error');
                  return;
              }
             updateStatus(state);
             updateLog(state.worldLog);
         });

         socket.on('availableActions', (actions) => {
             addDebugMessage(`Received ${actions ? actions.length : 0} actions.`);
             renderActions(actions);
         });

         socket.on('actionResult', (result) => {
              addDebugMessage(`Action Result: Success=${result.success}, Msg=${result.message}`);
              addLogMessage(result.message, result.success ? 'success' : 'error');

              if (result.success && result.event === "PROMPT_USER_FOR_TOOL_DESCRIPTION") { // Changed to result.event
                  addLogMessage("The Orb of Ingenuity hums...", 'event');
                  const userDescription = prompt("Describe the new power for the Orb (e.g., 'Create a temporary light bridge to the keyhole platform'):");
                  if (userDescription && userDescription.trim() !== "") {
                      socket.emit('submitToolDescription', {
                          description: userDescription.trim(),
                          catalyst_artifact_id: result.prompt_for_tool_artifact_id
                      });
                  } else {
                      addLogMessage("Orb command cancelled.", 'info');
                  }
              }
         });

          socket.on('debugInfo', (message) => {
              addDebugMessage(message);
          });

         socket.on('requestState', () => {
                addDebugMessage('Server requested state refresh.');
               if(playerSoulId) {
                   socket.emit('requestState');
               }
           });

         addLogMessage('Attempting to connect...');
     </script>
 </body>
 </html>
