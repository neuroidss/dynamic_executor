<!DOCTYPE html>
<html>
<head>
    <title>Infinite MMORPG - Orb of Ingenuity Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; height: 100vh; margin: 0; background-color: #111; color: #eee; overflow: hidden; font-size: 16px; }
        #game-container { position: relative; flex-grow: 1; width: 100%; height: 100%; display: flex; flex-direction: column; }
        #threejs-canvas { display: block; width: 100%; flex-grow: 1; cursor: default; }
        #threejs-canvas.pointer-locked { cursor: none; }

        .ui-overlay { position: absolute; background-color: rgba(0,0,0,0.5); padding: 3px; box-sizing: border-box; z-index: 10; border-radius: 3px; }

        #log-area { top: 5px; left: 5px; right: 5px; height: 12%; overflow-y: scroll; font-size: 0.7em; border: 1px solid #333;}
        #log-area p { margin: 1px 0; }
        #log-area h3 { display: none; }

        #status-area { top: calc(12% + 10px); left: 5px; width: 200px; height: auto; max-height: 15%; overflow-y: auto; font-size: 0.65em; border: 1px solid #333; padding: 5px;}
        #status-area strong { color: #aaffaa; }

        #action-area {
            position: absolute;
            bottom: 5px;
            left: 5px;
            right: 5px;
            height: 18%;
            background-color: rgba(0,0,0,0.7);
            border: 1px solid #444;
            border-radius: 5px;
            padding: 5px;
            overflow-y: auto;
            z-index: 20;
            font-size: 0.75em;
        }
        #action-buttons button {
            display: block;
            width: calc(100% - 10px);
            margin: 3px 5px;
            padding: 6px;
            background-color: #333;
            color: #eee;
            border: 1px solid #555;
            border-radius: 3px;
            cursor: pointer;
            text-align: left;
        }
        #action-buttons button:hover { background-color: #444; }
        #action-buttons p { color: #999; margin: 5px; text-align: center; }
        #action-buttons .desc { font-size: 0.8em; color: #bbb; display: block; margin-top: 2px;}

        #pointer-lock-action-hud {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.6);
            color: white;
            padding: 8px;
            border-radius: 4px;
            z-index: 100;
            font-size: 0.9em;
            display: none;
        }
        #pointer-lock-action-hud .action-item-hud { padding: 4px; cursor: pointer; }
        #pointer-lock-action-hud .action-item-hud:hover { background-color: rgba(255,255,255,0.1); }
        #pointer-lock-action-hud .selected-action-hud { background-color: rgba(255,255,255,0.2); border: 1px solid white; }
        #pointer-lock-action-hud #crosshair {
            position: fixed;
            top: 50%; left: 50%;
            width: 2px; height: 10px; background: white;
            transform: translate(-50%, -50%);
        }
        #pointer-lock-action-hud #crosshair::before {
            content: ''; display: block;
            width: 10px; height: 2px; background: white;
            position: absolute; top: 4px; left: -4px;
        }

        #debug-area { position: fixed; bottom: calc(18% + 10px); right: 5px; background: rgba(0,0,0,0.6); color: lime; font-family: monospace; font-size: 0.6em; max-height: 60px; width:100px; overflow-y: scroll; padding: 2px; opacity: 0.7; z-index: 100; border: 1px solid lime;}

        .joystick-zone { position: absolute; width: 120px; height: 120px; z-index: 50; }
        #joystick-move-zone { bottom: 30px; left: 30px; }
        #joystick-rotate-zone { bottom: 30px; right: 30px; }

        @media (max-width: 768px) {
           body { font-size: 14px; }
           #log-area { height: 10%; font-size: 0.65em;}
           #status-area { top: calc(10% + 10px); width: 180px; font-size: 0.6em; }
           #action-area { height: 20%; font-size: 0.7em; }
           #action-buttons button { padding: 5px; font-size: 0.75em; }
           .joystick-zone { width: 100px; height: 100px; }
           #joystick-move-zone { bottom: 20px; left: 20px; }
           #joystick-rotate-zone { bottom: 20px; right: 20px; }
        }
        @media (min-width: 769px) {
            #joystick-move-zone, #joystick-rotate-zone { display: none; }
        }
        @media (hover: none) and (pointer: coarse) {
            #joystick-move-zone, #joystick-rotate-zone { display: block !important; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js" integrity="sha384-mkQ3/7FUtcGyoppY6bz/PORYoGqOl7/aSUMn2ymDOJcapfS6PHqxhRTMh1RR0Q6+" crossorigin="anonymous"></script>
    <script src="https://yoannmoinet.github.io/nipplejs/javascripts/nipplejs.js"></script>
</head>
<body>
    <div id="game-container">
        <canvas id="threejs-canvas"></canvas>
        <div id="log-area" class="ui-overlay">
            <div id="log-content"></div>
        </div>
        <div id="status-area" class="ui-overlay"></div>
        <div id="action-area" class="ui-overlay">
            <div id="action-buttons"></div>
        </div>
        <div id="pointer-lock-action-hud" class="ui-overlay">
            <div id="crosshair"></div>
            <div id="hud-actions-list"></div>
        </div>
        <div id="joystick-move-zone" class="joystick-zone"></div>
        <div id="joystick-rotate-zone" class="joystick-zone"></div>
    </div>
    <div id="debug-area"><div id="debug-content"></div></div>

    <script>
        const socket = io();

        const logContent = document.getElementById('log-content');
        const logArea = document.getElementById('log-area');
        const statusArea = document.getElementById('status-area');
        const actionButtons = document.getElementById('action-buttons');
        const pointerLockActionHUD = document.getElementById('pointer-lock-action-hud');
        const hudActionsList = document.getElementById('hud-actions-list');
        const debugContent = document.getElementById('debug-content');
        const canvas = document.getElementById('threejs-canvas');

        let playerSoulId = null;
        let currentGameState = {};

        let scene, camera, renderer, playerAvatar;
        const landmarkObjects = {};
        const temporary3DObjects = {};
        let groundMeshes = {};

        let raycaster = new THREE.Raycaster();
        let highlightedObject = null;
        let lastSelectedTargetLandmarkKey = null;

        let lastFrameTime = performance.now();
        let previousPlayerPosition = new THREE.Vector3();

        let clientSideLastLocationId = null;
        const keyStates = {};
        let usingDesktopControls = false;

        const AUTO_SELECT_RADIUS_SQUARED = 2.5 * 2.5;
        const POINTER_LOCK_SELECT_RADIUS_SQUARED = 7.0 * 7.0;

        let availablePointerLockActions = [];
        let selectedPointerLockActionIndex = -1;

        let CAMERA_OFFSET = new THREE.Vector3(0, 2.5, 4.5); // Base offset
        let CAMERA_LOOK_AT_OFFSET_Y = 1.0;
        let PLAYER_MOVE_SPEED = 2.5;
        let PLAYER_ROTATE_SPEED = 1.5;
        let MOUSE_SENSITIVITY = 0.002;
        let UI_LOG_MAX_ENTRIES = 20;

        let cameraLookAtTarget = new THREE.Vector3();
        let desiredCameraPosition = new THREE.Vector3(); // To avoid re-creation in animate loop
        let playerPitch = 0;
        const MIN_PITCH = -Math.PI / 2 + 0.2;
        const MAX_PITCH = Math.PI / 2 - 0.2;

        let moveJoystick = null;
        let rotateJoystick = null;
        let moveVector = { x: 0, y: 0 };
        let rotateVector = { x: 0, y: 0 };

        let lastWheelTime = 0;
        const WHEEL_COOLDOWN_MS = 250; // Increased cooldown for touchpad scrolling

        function applyClientSettings(settings) {
            if (!settings) return;
            if (settings.camera) {
                if (settings.camera.offset_xyz) CAMERA_OFFSET.fromArray(settings.camera.offset_xyz);
                if (settings.camera.look_at_offset_y !== undefined) CAMERA_LOOK_AT_OFFSET_Y = settings.camera.look_at_offset_y;
            }
            if (settings.player_controls) {
                if (settings.player_controls.move_speed !== undefined) PLAYER_MOVE_SPEED = settings.player_controls.move_speed;
                if (settings.player_controls.rotate_speed !== undefined) PLAYER_ROTATE_SPEED = settings.player_controls.rotate_speed;
                if (settings.player_controls.mouse_sensitivity !== undefined) MOUSE_SENSITIVITY = settings.player_controls.mouse_sensitivity;
            }
            if (settings.ui && settings.ui.log_max_entries !== undefined) {
                UI_LOG_MAX_ENTRIES = settings.ui.log_max_entries;
            }
            addDebugMessage("Client settings applied/updated.");
        }


        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const playerGeometry = new THREE.CylinderGeometry(0.25, 0.25, 1, 16);
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x00dd00 });
            playerAvatar = new THREE.Mesh(playerGeometry, playerMaterial);
            playerAvatar.position.y = 0.5;
            playerAvatar.castShadow = true;
            scene.add(playerAvatar);
            previousPlayerPosition.copy(playerAvatar.position);

            const defaultGroundMaterial = new THREE.MeshStandardMaterial({ side: THREE.DoubleSide });
            groundMeshes['default_plane'] = new THREE.Mesh(new THREE.PlaneGeometry(1,1), defaultGroundMaterial.clone());
            groundMeshes['default_plane'].receiveShadow = true;
            groundMeshes['default_plane'].rotation.x = -Math.PI / 2;
            groundMeshes['default_plane'].name = "mainGroundPlane";
            scene.add(groundMeshes['default_plane']);

            groundMeshes['default_box_platform'] = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), defaultGroundMaterial.clone());
            groundMeshes['default_box_platform'].receiveShadow = true;
            groundMeshes['default_box_platform'].name = "boxPlatform";
            scene.add(groundMeshes['default_box_platform']);

            Object.values(groundMeshes).forEach(mesh => mesh.visible = false);


            setupControls();
            animate();
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupControls() {
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            usingDesktopControls = !isTouchDevice;

            const joystickMoveZoneEl = document.getElementById('joystick-move-zone');
            const joystickRotateZoneEl = document.getElementById('joystick-rotate-zone');

            if (isTouchDevice) {
                addDebugMessage("Touch device detected. Enabling virtual joysticks.");
                if (joystickMoveZoneEl) joystickMoveZoneEl.style.display = 'block';
                if (joystickRotateZoneEl) joystickRotateZoneEl.style.display = 'block';

                if (typeof NippleJS !== 'undefined' && NippleJS && joystickMoveZoneEl && joystickRotateZoneEl) {
                    moveJoystick = NippleJS.create({
                        zone: joystickMoveZoneEl, mode: 'static', position: { left: '50%', top: '50%' }, color: 'white', size: 80
                    });
                    moveJoystick.on('move', (evt, data) => {
                        const angle = data.angle.radian; const force = data.force > 1 ? 1 : data.force;
                        moveVector.x = Math.cos(angle) * force; moveVector.y = Math.sin(angle) * force;
                    });
                    moveJoystick.on('end', () => { moveVector.x = 0; moveVector.y = 0; });

                    rotateJoystick = NippleJS.create({
                        zone: joystickRotateZoneEl, mode: 'static', position: { left: '50%', top: '50%' }, color: 'white', size: 80
                    });
                    rotateJoystick.on('move', (evt, data) => {
                        const deadZone = 0.1; let dx = data.vector.x; let dy = data.vector.y;
                        if (Math.abs(dx) < deadZone) dx = 0; if (Math.abs(dy) < deadZone) dy = 0;
                        rotateVector.x = dx * 0.1; rotateVector.y = dy * 0.1;
                    });
                    rotateJoystick.on('end', () => { rotateVector.x = 0; rotateVector.y = 0; });
                    addDebugMessage("Joysticks initialized.");
                } else {
                    addDebugMessage("Joystick Init Failed. Touch relies on taps.");
                    if (joystickMoveZoneEl) joystickMoveZoneEl.style.display = 'none';
                    if (joystickRotateZoneEl) joystickRotateZoneEl.style.display = 'none';
                }
            } else {
                addDebugMessage("Desktop controls enabled.");
                if (joystickMoveZoneEl) joystickMoveZoneEl.style.display = 'none';
                if (joystickRotateZoneEl) joystickRotateZoneEl.style.display = 'none';
            }

            canvas.addEventListener('click', (event) => {
                if (usingDesktopControls) {
                    if (document.pointerLockElement !== canvas) {
                        canvas.requestPointerLock().catch(err => {
                            addDebugMessage("Pointer lock failed: " + err.message + ". Fallback click.");
                            handleInteractionClick(event);
                        });
                    }
                } else {
                    handleInteractionClick(event);
                }
            });

            document.addEventListener('pointerlockchange', () => {
                if (usingDesktopControls) {
                    if (document.pointerLockElement === canvas) {
                        addDebugMessage("Pointer locked"); pointerLockActionHUD.style.display = 'block';
                        lastSelectedTargetLandmarkKey = null; updateContextualActionsDisplay();
                    } else {
                        addDebugMessage("Pointer unlocked"); pointerLockActionHUD.style.display = 'none';
                        for (const key in keyStates) keyStates[key] = false;
                    }
                }
            });
            document.addEventListener('pointerlockerror', () => { if(usingDesktopControls) addDebugMessage("Pointer lock error."); });
            document.addEventListener('keydown', (event) => { if (usingDesktopControls) { keyStates[event.key.toLowerCase()] = true; if (document.pointerLockElement === canvas && (event.key === 'Enter' || event.key.toLowerCase() === 'e')) { executeSelectedPointerLockAction(); event.preventDefault(); } } });
            document.addEventListener('keyup', (event) => { if (usingDesktopControls) { keyStates[event.key.toLowerCase()] = false; } });
            document.addEventListener('mousemove', (event) => { if (usingDesktopControls && document.pointerLockElement === canvas && playerAvatar) { playerAvatar.rotation.y -= event.movementX * MOUSE_SENSITIVITY; playerPitch += event.movementY * MOUSE_SENSITIVITY; playerPitch = Math.max(MIN_PITCH, Math.min(MAX_PITCH, playerPitch)); } });
            canvas.addEventListener('wheel', (event) => { if (usingDesktopControls && document.pointerLockElement === canvas && availablePointerLockActions.length > 0) { event.preventDefault(); const currentTime = performance.now(); if (currentTime - lastWheelTime > WHEEL_COOLDOWN_MS) { selectedPointerLockActionIndex -= Math.sign(event.deltaY); if (selectedPointerLockActionIndex < 0) selectedPointerLockActionIndex = availablePointerLockActions.length - 1; if (selectedPointerLockActionIndex >= availablePointerLockActions.length) selectedPointerLockActionIndex = 0; updatePointerLockHUD(); lastWheelTime = currentTime; } } });
        }

        function handleInteractionClick(event) {
            if (!currentGameState || !currentGameState.currentLocation || !playerAvatar || (usingDesktopControls && document.pointerLockElement === canvas)) return;
            const rect = canvas.getBoundingClientRect(); const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const interactableMeshes = Object.values(landmarkObjects).filter(m => m.userData.isInteractable !== false);
            const intersects = raycaster.intersectObjects(interactableMeshes, false);

            let clickedTargetKey = null;
            if (intersects.length > 0) clickedTargetKey = intersects[0].object.userData.landmarkKey;

            if (clickedTargetKey !== lastSelectedTargetLandmarkKey) {
                if (lastSelectedTargetLandmarkKey && landmarkObjects[lastSelectedTargetLandmarkKey]) {
                     try { landmarkObjects[lastSelectedTargetLandmarkKey].material.emissive.setHex(0x000000); } catch(e){}
                } else if (highlightedObject) { try { highlightedObject.material.emissive.setHex(0x000000); } catch(e){} }

                lastSelectedTargetLandmarkKey = clickedTargetKey;
                highlightedObject = lastSelectedTargetLandmarkKey ? landmarkObjects[lastSelectedTargetLandmarkKey] : null;
                if (highlightedObject) { try {highlightedObject.material.emissive.setHex(0x555555); } catch(e){} }
                addDebugMessage("Clicked Target LM Key: " + (lastSelectedTargetLandmarkKey || "None"));
                updateContextualActionsDisplay();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const currentTime = performance.now(); const deltaTime = (currentTime - lastFrameTime) / 1000; lastFrameTime = currentTime;

            if (playerAvatar) {
                const moveSpeed = PLAYER_MOVE_SPEED * deltaTime; const rotateSpeed = PLAYER_ROTATE_SPEED * deltaTime;
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerAvatar.quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(playerAvatar.quaternion);

                if (usingDesktopControls && document.pointerLockElement === canvas) {
                    if (keyStates['w']) playerAvatar.position.addScaledVector(forward, moveSpeed); if (keyStates['s']) playerAvatar.position.addScaledVector(forward, -moveSpeed);
                    if (keyStates['a']) playerAvatar.position.addScaledVector(right, -moveSpeed); if (keyStates['d']) playerAvatar.position.addScaledVector(right, moveSpeed);
                } else if (!usingDesktopControls && moveJoystick) {
                    if (moveVector.y !== 0) playerAvatar.position.addScaledVector(forward.clone().multiplyScalar(moveVector.y > 0 ? 1 : -1), Math.abs(moveVector.y) * moveSpeed);
                    if (moveVector.x !== 0) playerAvatar.position.addScaledVector(right.clone().multiplyScalar(moveVector.x > 0 ? 1 : -1), Math.abs(moveVector.x) * moveSpeed);
                    if (rotateVector.x !== 0) playerAvatar.rotation.y -= rotateVector.x * rotateSpeed * 2;
                    if (rotateVector.y !== 0) { playerPitch -= rotateVector.y * rotateSpeed * 1.5; playerPitch = Math.max(MIN_PITCH, Math.min(MAX_PITCH, playerPitch)); }
                }

                // Camera Logic Update
                cameraLookAtTarget.copy(playerAvatar.position).add(new THREE.Vector3(0, CAMERA_LOOK_AT_OFFSET_Y, 0));

                const camDist = CAMERA_OFFSET.z; // Use the Z component of CAMERA_OFFSET for distance
                const horizontalDist = camDist * Math.cos(playerPitch);
                const verticalDist = camDist * Math.sin(playerPitch);

                // Calculate camera position based on player's yaw (playerAvatar.rotation.y) and pitch (playerPitch)
                // MODIFIED: Changed signs from subtraction to addition for X and Z to position camera behind player
                desiredCameraPosition.x = cameraLookAtTarget.x + horizontalDist * Math.sin(playerAvatar.rotation.y);
                desiredCameraPosition.y = cameraLookAtTarget.y + verticalDist + (CAMERA_OFFSET.y - CAMERA_LOOK_AT_OFFSET_Y);
                desiredCameraPosition.z = cameraLookAtTarget.z + horizontalDist * Math.cos(playerAvatar.rotation.y);

                camera.position.lerp(desiredCameraPosition, 0.1); // Smooth camera movement
                camera.lookAt(cameraLookAtTarget);


                let currentFrameSelectedTargetKey = null;
                if (usingDesktopControls && document.pointerLockElement === canvas && camera) {
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const interactableMeshes = Object.values(landmarkObjects).filter(m => m.userData.isInteractable !== false);
                    const intersects = raycaster.intersectObjects(interactableMeshes, false);
                    if (intersects.length > 0) {
                        const closestIntersected = intersects[0].object;
                        if (playerAvatar.position.distanceToSquared(closestIntersected.position) < POINTER_LOCK_SELECT_RADIUS_SQUARED) {
                            currentFrameSelectedTargetKey = closestIntersected.userData.landmarkKey;
                        }
                    }
                } else if (!usingDesktopControls || document.pointerLockElement !== canvas) {
                    if (lastSelectedTargetLandmarkKey && landmarkObjects[lastSelectedTargetLandmarkKey]) {
                        currentFrameSelectedTargetKey = lastSelectedTargetLandmarkKey;
                    } else if (currentGameState.currentLocation && currentGameState.currentLocation.landmarks) {
                        let closestDistSq = AUTO_SELECT_RADIUS_SQUARED; let potentialTargetKey = null;
                        for (const lmKey in landmarkObjects) {
                            const landmarkMesh = landmarkObjects[lmKey];
                            if (landmarkMesh.userData.isInteractable === false) continue;
                            if (playerAvatar.position.distanceToSquared(landmarkMesh.position) < closestDistSq) {
                                closestDistSq = playerAvatar.position.distanceToSquared(landmarkMesh.position); potentialTargetKey = lmKey;
                            }
                        }
                        currentFrameSelectedTargetKey = potentialTargetKey;
                    }
                }

                if (currentFrameSelectedTargetKey !== lastSelectedTargetLandmarkKey) {
                    if (lastSelectedTargetLandmarkKey && landmarkObjects[lastSelectedTargetLandmarkKey]) {
                        try { landmarkObjects[lastSelectedTargetLandmarkKey].material.emissive.setHex(0x000000); } catch(e){}
                    } else if (highlightedObject) { try { highlightedObject.material.emissive.setHex(0x000000); } catch(e){} }

                    lastSelectedTargetLandmarkKey = currentFrameSelectedTargetKey;
                    highlightedObject = (lastSelectedTargetLandmarkKey && landmarkObjects[lastSelectedTargetLandmarkKey]) ? landmarkObjects[lastSelectedTargetLandmarkKey] : null;
                    if (highlightedObject) { try { highlightedObject.material.emissive.setHex( (usingDesktopControls && document.pointerLockElement === canvas) ? 0x222222 : 0x555555); } catch(e){} }
                    updateContextualActionsDisplay();
                }
                if (!playerAvatar.position.equals(previousPlayerPosition)) { previousPlayerPosition.copy(playerAvatar.position); }
            }
            renderer.render(scene, camera);
        }

        function updatePointerLockHUD() {
            if (!pointerLockActionHUD || !hudActionsList) return;
            if (!usingDesktopControls || document.pointerLockElement !== canvas || availablePointerLockActions.length === 0) {
                pointerLockActionHUD.style.display = 'none'; return;
            }
            pointerLockActionHUD.style.display = 'block'; hudActionsList.innerHTML = '';
            availablePointerLockActions.forEach((action, index) => {
                const div = document.createElement('div'); div.className = 'action-item-hud'; div.textContent = action.name;
                if (index === selectedPointerLockActionIndex) div.classList.add('selected-action-hud');
                div.onclick = () => { if (usingDesktopControls && document.pointerLockElement === canvas) { selectedPointerLockActionIndex = index; executeSelectedPointerLockAction(); } };
                hudActionsList.appendChild(div);
            });
            if (availablePointerLockActions.length > 0) {
                const helpText = document.createElement('div'); helpText.textContent = '(Scroll/Click, E/Enter to use)';
                helpText.style.cssText = 'font-size:0.8em; text-align:center; margin-top:5px; color:#ccc;';
                hudActionsList.appendChild(helpText);
            }
        }

        function executeSelectedPointerLockAction() {
            if (usingDesktopControls && document.pointerLockElement === canvas && selectedPointerLockActionIndex !== -1 && availablePointerLockActions[selectedPointerLockActionIndex]) {
                const action = availablePointerLockActions[selectedPointerLockActionIndex];
                addDebugMessage(`Executing PL Action: ${action.name}`);
                if (action.type === 'move') socket.emit('playerMove', action.params);
                else if (action.type === 'action') socket.emit('performAction', action.params);
            }
        }

        function addLogMessage(message, type = 'info') {
            const p = document.createElement('p'); p.textContent = message;
            if (type === 'error') p.style.color = '#ffaaaa'; if (type === 'success') p.style.color = '#aaffaa';
            if (type === 'event') { p.style.color = '#aaaaff'; p.style.fontStyle = 'italic';}
            logContent.insertBefore(p, logContent.firstChild);
            while (logContent.children.length > UI_LOG_MAX_ENTRIES) { logContent.removeChild(logContent.lastChild); }
            logArea.scrollTop = 0;
        }
        function addDebugMessage(message) {
            const d = document.createElement('div'); d.textContent = message;
            debugContent.appendChild(d); if(debugContent.children.length > 10) { debugContent.removeChild(debugContent.firstChild); }
            debugContent.scrollTop = debugContent.scrollHeight;
        }

        function setupLocationVisuals(locationData) {
            Object.values(groundMeshes).forEach(mesh => mesh.visible = false);
            if (!locationData || !locationData.client_visual_config) {
                addDebugMessage("No visual config for location, using fallback ground.");
                const fallbackPlane = groundMeshes['default_plane'];
                if (fallbackPlane) {
                    fallbackPlane.visible = true;
                    fallbackPlane.position.set(0,0,0);
                    fallbackPlane.scale.set(20,20,1);
                    fallbackPlane.material.color.setHex(0x303030);
                }
                return;
            }

            const config = locationData.client_visual_config;
            const groundConfig = config.ground_config || {};
            const center = new THREE.Vector3().fromArray(config.center_position_xyz || [0,0,0]);
            const groundColor = parseInt((groundConfig.color_hex || "#3a3a3a").replace("#",""), 16);

            if (config.ground_type_key === 'flat_plane') {
                const plane = groundMeshes['default_plane'];
                if(plane) {
                    plane.visible = true;
                    plane.position.copy(center);
                    const size = groundConfig.size_xz || [20,20];
                    plane.scale.set(size[0], size[1], 1);
                    plane.material.color.setHex(groundColor);
                }
            } else if (config.ground_type_key === 'split_chasm_platforms') {
                const playerPlatformMesh = groundMeshes['default_box_platform'];
                // Remove old temporary keyhole platform mesh if it exists
                if(groundMeshes['keyhole_platform_temp']) {
                    scene.remove(groundMeshes['keyhole_platform_temp']);
                    groundMeshes['keyhole_platform_temp'].geometry?.dispose();
                    groundMeshes['keyhole_platform_temp'].material?.dispose();
                    delete groundMeshes['keyhole_platform_temp'];
                }
                const keyholePlatformMesh = groundMeshes['default_box_platform'].clone();
                keyholePlatformMesh.receiveShadow = true;
                scene.add(keyholePlatformMesh);
                groundMeshes['keyhole_platform_temp'] = keyholePlatformMesh;

                if(playerPlatformMesh && keyholePlatformMesh) {
                    playerPlatformMesh.visible = true; keyholePlatformMesh.visible = true;

                    const pSize = groundConfig.player_platform_size_xyz || [5,0.2,4];
                    playerPlatformMesh.scale.fromArray(pSize);
                    playerPlatformMesh.position.set(center.x, center.y - pSize[1]/2, center.z);
                    playerPlatformMesh.material.color.setHex(groundColor);

                    const kSize = groundConfig.keyhole_platform_size_xyz || [3,0.2,3];
                    keyholePlatformMesh.scale.fromArray(kSize);
                    const kRelPos = groundConfig.keyhole_platform_relative_pos_xz || [0, -4];
                    keyholePlatformMesh.position.set(center.x + kRelPos[0], center.y - kSize[1]/2, center.z + kRelPos[1]);
                    keyholePlatformMesh.material.color.setHex(groundColor);
                }
            } else if (config.ground_type_key === 'none') {
                 scene.background = new THREE.Color(groundColor);
            } else {
                 const fallbackPlane = groundMeshes['default_plane'];
                 if(fallbackPlane){
                    fallbackPlane.visible = true; fallbackPlane.position.copy(center);
                    fallbackPlane.scale.set(20,20,1); fallbackPlane.material.color.setHex(0x303030);
                 }
            }
        }

        function createGeometryFromConfig(geomConfig) {
            if (!geomConfig || !geomConfig.type) return new THREE.SphereGeometry(0.1, 8, 6);

            const type = geomConfig.type.toLowerCase();
            const params = geomConfig.parameters || {};
            const dims = geomConfig.dimensions || [0.2, 0.2, 0.2];
            const radius = geomConfig.radius || 0.2;
            const segments = geomConfig.segments || [12, 8];

            switch(type) {
                case 'box': return new THREE.BoxGeometry(dims[0] || params.width || 0.2, dims[1] || params.height || 0.2, dims[2] || params.depth || 0.2);
                case 'sphere': return new THREE.SphereGeometry(radius, segments[0] || 12, segments[1] || 8);
                case 'cylinder': return new THREE.CylinderGeometry(params.radiusTop || radius, params.radiusBottom || radius, params.height || dims[1] || 0.5, params.radialSegments || segments[0] || 12);
                case 'plane': return new THREE.PlaneGeometry(dims[0] || 1, dims[1] || 1);
                default: return new THREE.SphereGeometry(0.1, 8, 6);
            }
        }

        function updateLandmarks3D(locationData, envObjectsInLocation, allPuzzleStates) {
            if (highlightedObject) { try { highlightedObject.material.emissive.setHex(0x000000); } catch (e) {} }
            highlightedObject = null;

            for (const key in landmarkObjects) {
                if(landmarkObjects[key]) { scene.remove(landmarkObjects[key]); landmarkObjects[key].geometry?.dispose(); landmarkObjects[key].material?.dispose(); }
                delete landmarkObjects[key];
            }

            if (!locationData || !locationData.landmarks || !locationData.client_visual_config) return;

            const locCenter = new THREE.Vector3().fromArray(locationData.client_visual_config.center_position_xyz || [0,0,0]);

            for (const [landmarkKey, landmarkData] of Object.entries(locationData.landmarks)) {
                const visConfig = landmarkData.client_visual_config;
                if (!visConfig) continue;

                const relPos = new THREE.Vector3().fromArray(visConfig.relative_position_xyz || [0,0.25,0]);
                const absPos = relPos.clone().add(locCenter);

                const landmarkGeo = createGeometryFromConfig(visConfig.geometry_config);

                let currentBaseColorHex = (visConfig.material_config && visConfig.material_config.base_color_hex) || "#aaaaaa";
                let currentEmissiveColorHex = (visConfig.material_config && visConfig.material_config.emissive_color_hex) || "#000000";
                let currentEmissiveIntensity = (visConfig.material_config && visConfig.material_config.emissive_intensity) || 0;
                let isTransparent = (visConfig.material_config && visConfig.material_config.transparent) || false;
                let currentOpacity = (visConfig.material_config && visConfig.material_config.opacity) || 1.0;


                let isInteractable = visConfig.landmark_interaction_type_key !== 'door_inert';

                const targetEnvId = visConfig.targetable_as_env_object_id;
                if (targetEnvId && envObjectsInLocation) {
                    const linkedEnvObject = envObjectsInLocation.find(obj => obj.id === targetEnvId);
                    if (linkedEnvObject && linkedEnvObject.details && linkedEnvObject.details.client_visual_update) {
                        const visualUpdate = linkedEnvObject.details.client_visual_update;
                        if (visualUpdate.new_color_hex) currentBaseColorHex = visualUpdate.new_color_hex;
                        if (visualUpdate.emissive_color_hex) currentEmissiveColorHex = visualUpdate.emissive_color_hex;
                        if (visualUpdate.emissive_intensity !== undefined) currentEmissiveIntensity = visualUpdate.emissive_intensity;
                    }
                }

                // Handle open state visual changes (like the sealed door becoming transparent)
                 if (visConfig.is_exit_to_location_id && visConfig.linked_puzzle_id_for_open_state) {
                    const puzzle = allPuzzleStates?.[visConfig.linked_puzzle_id_for_open_state];
                    if (puzzle && (puzzle.is_complete || puzzle.is_open) ) {
                         // Check if the open state config has specific visual overrides
                         if (visConfig.material_config && visConfig.material_config.open_color_hex) {
                            currentBaseColorHex = visConfig.material_config.open_color_hex;
                         }
                         if (visConfig.material_config && visConfig.material_config.open_emissive_color_hex) {
                            currentEmissiveColorHex = visConfig.material_config.open_emissive_color_hex;
                            currentEmissiveIntensity = visConfig.material_config.open_emissive_intensity !== undefined ? visConfig.material_config.open_emissive_intensity : currentEmissiveIntensity;
                         }
                         if (visConfig.material_config && visConfig.material_config.open_transparent !== undefined) {
                             isTransparent = visConfig.material_config.open_transparent;
                             currentOpacity = visConfig.material_config.open_opacity !== undefined ? visConfig.material_config.open_opacity : currentOpacity;
                         } else if (visConfig.material_config && visConfig.material_config.base_color_hex === '#77CC77') { // Check if it was directly set by server handler
                             // If the server handler set the base color to the 'open' color, assume it's open
                             // This is a fallback/heuristic based on the current server logic
                             isTransparent = true; // Assume open means transparent
                             currentOpacity = 0.0; // Assume open means invisible
                         }
                    }
                }
                 if (visConfig.landmark_interaction_type_key === 'door_inert' && visConfig.linked_puzzle_id_for_open_state) {
                    const puzzle = allPuzzleStates?.[visConfig.linked_puzzle_id_for_open_state];
                    if (puzzle && puzzle.is_open) {
                         if (visConfig.material_config && visConfig.material_config.open_color_hex) {
                            currentBaseColorHex = visConfig.material_config.open_color_hex;
                         } else if (visConfig.material_config && visConfig.material_config.base_color_hex === '#90EE90') {
                            currentBaseColorHex = visConfig.material_config.base_color_hex;
                         }
                         if (visConfig.material_config && visConfig.material_config.open_transparent !== undefined) {
                             isTransparent = visConfig.material_config.open_transparent;
                             currentOpacity = visConfig.material_config.open_opacity !== undefined ? visConfig.material_config.open_opacity : currentOpacity;
                         }
                    }
                }


                const landmarkMat = new THREE.MeshStandardMaterial({
                    color: parseInt(currentBaseColorHex.replace("#",""), 16),
                    emissive: parseInt(currentEmissiveColorHex.replace("#",""), 16),
                    emissiveIntensity: currentEmissiveIntensity,
                    transparent: isTransparent,
                    opacity: currentOpacity
                });
                 if (currentEmissiveIntensity > 0 || isTransparent) {
                     landmarkMat.toneMapped = false; // For emissive to glow properly and transparency sorting
                 }


                const landmarkMesh = new THREE.Mesh(landmarkGeo, landmarkMat);
                landmarkMesh.position.copy(absPos);
                landmarkMesh.userData = {
                    landmarkKey: landmarkKey,
                    name: landmarkData.name || landmarkKey,
                    type: 'landmark',
                    isInteractable: isInteractable,
                    targetEnvId: targetEnvId,
                    isExitTo: visConfig.is_exit_to_location_id,
                    interactionTypeKey: visConfig.landmark_interaction_type_key || visConfig.interaction_type, // Added fallback for interaction_type
                    client_visual_config: visConfig // Store full visConfig for action checks
                };
                scene.add(landmarkMesh);
                landmarkObjects[landmarkKey] = landmarkMesh;
            }
        }


        function updateTemporaryObjects3D(tempObjectsData, currentLocationData) {
             for (const objId in temporary3DObjects) {
                const objStillExists = tempObjectsData && tempObjectsData.find(obj => obj.id === objId && obj.location_id === currentLocationData?.id && obj.duration > 0);
                if (!objStillExists) {
                    if(temporary3DObjects[objId]) { scene.remove(temporary3DObjects[objId]); temporary3DObjects[objId].geometry?.dispose(); temporary3DObjects[objId].material?.dispose(); }
                    delete temporary3DObjects[objId];
                }
            }
            if (!tempObjectsData || !currentLocationData || !currentLocationData.landmarks || !currentLocationData.client_visual_config) return;

            const locCenter = new THREE.Vector3().fromArray(currentLocationData.client_visual_config.center_position_xyz || [0,0,0]);

            tempObjectsData.forEach(obj => {
                if (obj.location_id !== currentLocationData.id || obj.duration <= 0 || temporary3DObjects[obj.id]) return;
                const visConfig = obj.client_visual_config || {};
                const geomConfig = visConfig.geometry_config || {};
                const matConfig = visConfig.material_config || {};


                if (geomConfig.type === 'bridge_between_landmarks') {
                    const fromLandmarkData = currentLocationData.landmarks[obj.from_landmark_id];
                    const toLandmarkData = currentLocationData.landmarks[obj.to_landmark_id];

                    if (!fromLandmarkData || !toLandmarkData || !fromLandmarkData.client_visual_config || !toLandmarkData.client_visual_config) {
                        addDebugMessage(`Bridge failed: missing landmark data for ${obj.from_landmark_id} or ${obj.to_landmark_id}`);
                        return;
                    }

                    const fromPosRel = new THREE.Vector3().fromArray(fromLandmarkData.client_visual_config.relative_position_xyz);
                    const toPosRel = new THREE.Vector3().fromArray(toLandmarkData.client_visual_config.relative_position_xyz);
                    const fromPosAbs = fromPosRel.clone().add(locCenter);
                    const toPosAbs = toPosRel.clone().add(locCenter);

                    const yOffset = geomConfig.parameters?.y_offset || 0.1;
                    fromPosAbs.y += yOffset; toPosAbs.y += yOffset;

                    const distance = fromPosAbs.distanceTo(toPosAbs);
                    if (distance < 0.01) return;

                    const bridgeMaterial = new THREE.MeshStandardMaterial({ // Use StandardMaterial for emissive
                        color: parseInt((matConfig.base_color_hex || "#33ccff").replace("#",""), 16),
                        transparent: matConfig.transparent !== undefined ? matConfig.transparent : true,
                        opacity: matConfig.opacity || 0.6,
                        side: THREE.DoubleSide,
                        emissive: parseInt((matConfig.emissive_color_hex || "#000000").replace("#",""), 16),
                        emissiveIntensity: matConfig.emissive_intensity || 0
                    });
                     if (matConfig.emissive_intensity > 0 || (matConfig.transparent !== undefined ? matConfig.transparent : true)) {
                        bridgeMaterial.toneMapped = false;
                     }

                    const bridgeWidth = geomConfig.parameters?.width || 0.6;
                    const bridgeHeight = geomConfig.parameters?.height || 0.08;
                    const bridgeGeometry = new THREE.BoxGeometry(bridgeWidth, bridgeHeight, distance);

                    const bridgeMesh = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
                    bridgeMesh.position.copy(fromPosAbs).lerp(toPosAbs, 0.5);
                    const direction = new THREE.Vector3().subVectors(toPosAbs, fromPosAbs).normalize();
                    const alignQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), direction);
                    bridgeMesh.quaternion.copy(alignQuaternion);

                    scene.add(bridgeMesh);
                    temporary3DObjects[obj.id] = bridgeMesh;
                } else if (geomConfig.type) {
                     const tempGeo = createGeometryFromConfig(geomConfig);
                     const tempMat = new THREE.MeshStandardMaterial({
                         color: parseInt((matConfig.base_color_hex || "#ffaa00").replace("#",""), 16),
                         transparent: matConfig.transparent || false,
                         opacity: matConfig.opacity || 1.0,
                         emissive: parseInt((matConfig.emissive_color_hex || "#000000").replace("#",""), 16),
                         emissiveIntensity: matConfig.emissive_intensity || 0
                     });
                     if (matConfig.emissive_intensity > 0 || matConfig.transparent) {
                        tempMat.toneMapped = false; // For emissive to glow properly without tone mapping dimming it
                     }
                     const tempMesh = new THREE.Mesh(tempGeo, tempMat);

                     let fromPosAbs = playerAvatar.position.clone(); // Default 'player_current_pos'
                     if(obj.from_landmark_id !== 'player_current_pos' && currentLocationData.landmarks[obj.from_landmark_id]?.client_visual_config?.relative_position_xyz) {
                        fromPosAbs.fromArray(currentLocationData.landmarks[obj.from_landmark_id].client_visual_config.relative_position_xyz).add(locCenter);
                     }

                     let toPosAbs = new THREE.Vector3();
                     if(currentLocationData.landmarks[obj.to_landmark_id]?.client_visual_config?.relative_position_xyz) {
                        toPosAbs.fromArray(currentLocationData.landmarks[obj.to_landmark_id].client_visual_config.relative_position_xyz).add(locCenter);
                     } else {
                        addDebugMessage(`Temp obj ${obj.id} target landmark ${obj.to_landmark_id} not found for positioning.`);
                        toPosAbs.copy(fromPosAbs).add(new THREE.Vector3(0,0,-2)); // Default offset if target missing
                     }

                     const distance = fromPosAbs.distanceTo(toPosAbs);
                     tempMesh.position.copy(fromPosAbs).lerp(toPosAbs, 0.5); // Center it

                     if (geomConfig.type === 'box' && geomConfig.parameters) { // Scale Z for box "bridge"
                        // Assuming the box depth parameter is the intended length axis
                        const boxDepth = geomConfig.parameters.depth || 1.0;
                        if (boxDepth > 0.001) { // Avoid division by zero
                            tempMesh.scale.z = distance / boxDepth;
                        } else {
                             tempMesh.scale.z = distance; // Fallback if depth is zero or very small
                        }
                     }

                     const direction = new THREE.Vector3().subVectors(toPosAbs, fromPosAbs).normalize();
                     if (direction.lengthSq() > 0.001) { // Avoid issues with zero vector
                        const alignQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), direction);
                        tempMesh.quaternion.copy(alignQuaternion);
                     }

                     scene.add(tempMesh);
                     temporary3DObjects[obj.id] = tempMesh;
                }
            });
        }


        function updateStatus(state) {
              if (!state || !state.playerSoul ) { statusArea.innerHTML = "Connecting..."; return; }
              currentGameState = state;
              if (state.worldProperties && state.worldProperties.client_default_settings) {
                  applyClientSettings(state.worldProperties.client_default_settings);
              }
              const worldProps = state.worldProperties || {};
              const uiMessages = worldProps.ui_messages || {};
              const uiSpecialNames = worldProps.ui_special_location_names || {};


              let currentLocationDisplay = state.currentLocation;
              if (!currentLocationDisplay || state.playerSoul.locationId === "LIMBO_VOID") {
                  currentLocationDisplay = {
                      id: "LIMBO_VOID",
                      name: uiSpecialNames.limbo_void || "The Void",
                      description: uiMessages.limbo_void_description || "Adrift...",
                      exits: {},
                      landmarks: {},
                      client_visual_config: worldProps.void_visual_config || {center_position_xyz: [0,-50,-100], ground_type_key: 'none', ground_config: {color_hex: '#100510'}}
                    };
              }

              let statusHTML = `<strong>${state.playerSoul.name}</strong> @ ${currentLocationDisplay.name}<br>`;
              if (state.inventory && state.inventory.length > 0) {
                statusHTML += `Inv: ${state.inventory.map(a => a.name.length > 15 ? a.name.substring(0,12)+"..." : a.name ).join(', ') }`;
              } else { statusHTML += `Inv: Empty`; }
              statusArea.innerHTML = statusHTML;

              if (playerAvatar) {
                  const newLocationId = state.playerSoul.locationId || "LIMBO_VOID";
                  if (newLocationId !== clientSideLastLocationId) {
                      addDebugMessage(`Loc change: ${clientSideLastLocationId} -> ${newLocationId}`);
                      const locVisConfig = currentLocationDisplay.client_visual_config;
                      let targetPlayerPos = new THREE.Vector3().fromArray(locVisConfig?.center_position_xyz || [0,0,0]);
                      playerAvatar.position.copy(targetPlayerPos); playerAvatar.position.y = 0.5;
                      previousPlayerPosition.copy(playerAvatar.position);
                      playerAvatar.rotation.y = 0; playerPitch = 0;
                      clientSideLastLocationId = newLocationId;

                      // Remove all temporary objects when changing location
                      for (const objId in temporary3DObjects) {
                           if(temporary3DObjects[objId]) { scene.remove(temporary3DObjects[objId]); temporary3DObjects[objId].geometry?.dispose(); temporary3DObjects[objId].material?.dispose(); }
                           delete temporary3DObjects[objId];
                      }

                      setupLocationVisuals(currentLocationDisplay);
                      updateLandmarks3D(currentLocationDisplay, state.environmentObjectsInLocation, state.allPuzzleStates);
                      lastSelectedTargetLandmarkKey = null;
                  } else {
                     updateLandmarks3D(currentLocationDisplay, state.environmentObjectsInLocation, state.allPuzzleStates);
                  }
                  updateTemporaryObjects3D(state.activeTemporaryObjects, currentLocationDisplay);
              }
        }
        function updateLog(logEntries) {
              if (!logEntries) return;
              logEntries.slice().reverse().forEach(msg => {
                const existing = Array.from(logContent.querySelectorAll('p')).find(p => p.textContent === msg);
                if(!existing) addLogMessage(msg);
              });
        }

        function updateContextualActionsDisplay() {
            actionButtons.innerHTML = ''; availablePointerLockActions = []; selectedPointerLockActionIndex = -1;
            const playerSoul = currentGameState.playerSoul; const currentLocation = currentGameState.currentLocation;
            const inventory = currentGameState.inventory; const allPuzzles = currentGameState.allPuzzleStates;

            if (lastSelectedTargetLandmarkKey && currentLocation && currentLocation.landmarks && currentLocation.landmarks[lastSelectedTargetLandmarkKey]) {
                const debugSelectedLandmarkData = currentLocation.landmarks[lastSelectedTargetLandmarkKey];
                const debugSelectedLandmarkVisConfig = debugSelectedLandmarkData.client_visual_config; // Corrected: snake_case
                if (debugSelectedLandmarkVisConfig) {
                    console.log("[DEBUG] Selected Landmark Key:", lastSelectedTargetLandmarkKey);
                    console.log("[DEBUG] Selected Landmark Name:", debugSelectedLandmarkData.name);
                    console.log("[DEBUG] Selected Landmark VisConfig:", JSON.stringify(debugSelectedLandmarkVisConfig));
                    addDebugMessage(`SLMK: ${lastSelectedTargetLandmarkKey}`);
                    addDebugMessage(`LMIKey: ${debugSelectedLandmarkVisConfig.landmark_interaction_type_key}`);
                    addDebugMessage(`LMIntType: ${debugSelectedLandmarkVisConfig.interaction_type}`);
                } else {
                    console.log("[DEBUG] Selected landmark has no client_visual_config:", lastSelectedTargetLandmarkKey);
                    addDebugMessage(`SLMK ${lastSelectedTargetLandmarkKey} no visConfig`);
                }
            }

            if (!playerSoul || !currentLocation ) {
                actionButtons.innerHTML = '<p>Loading location data...</p>'; updatePointerLockHUD(); return;
            }

            const landmarksInLocation = currentLocation.landmarks || {};

            const selectedLandmarkData = lastSelectedTargetLandmarkKey ? landmarksInLocation[lastSelectedTargetLandmarkKey] : null;
            const selectedLandmarkVisConfig = selectedLandmarkData ? selectedLandmarkData.client_visual_config : null; // Corrected: snake_case

            if (selectedLandmarkData && selectedLandmarkVisConfig) {
                const targetName = selectedLandmarkData.name || lastSelectedTargetLandmarkKey;
                if (selectedLandmarkVisConfig.is_exit_to_location_id) {
                    let canEnter = true;
                    let doorMessage = `Go to ${selectedLandmarkVisConfig.is_exit_to_location_id}`;
                    const exitDisplayName = selectedLandmarkVisConfig.display_name || targetName;
                    doorMessage = `Go to ${exitDisplayName}`;


                    if (selectedLandmarkVisConfig.linked_puzzle_id_for_open_state) {
                        const puzzle = allPuzzles?.[selectedLandmarkVisConfig.linked_puzzle_id_for_open_state];
                        if (puzzle && !puzzle.is_complete && !puzzle.is_open) {
                             canEnter = false;
                             doorMessage = `${exitDisplayName} is sealed.`;
                             if (puzzle.custom_sealed_message) doorMessage = puzzle.custom_sealed_message;
                        }
                    }

                    if(canEnter){
                        const actionParams = { type: 'move', params: { exit_key: lastSelectedTargetLandmarkKey }, name: doorMessage };
                        availablePointerLockActions.push(actionParams);
                        const button = document.createElement('button'); button.innerHTML = doorMessage;
                        button.onclick = () => socket.emit('playerMove', { exit_key: lastSelectedTargetLandmarkKey });
                        actionButtons.appendChild(button);
                    } else { const p = document.createElement('p'); p.textContent = doorMessage; p.style.color = '#aaa'; actionButtons.appendChild(p); }
                }

                if (inventory) {
                    inventory.forEach(item => {
                        const itemInteractionRules = item.properties?.client_interaction_rules;
                        if (itemInteractionRules && Array.isArray(itemInteractionRules)) {
                            itemInteractionRules.forEach(rule => {
                                const actualLandmarkInteractionType = selectedLandmarkVisConfig ? (selectedLandmarkVisConfig.landmark_interaction_type_key || selectedLandmarkVisConfig.interaction_type) : null;
                                if (rule.requires_landmark_interaction_type_key && selectedLandmarkVisConfig) {
                                     addDebugMessage(`Rule LMI: ${rule.requires_landmark_interaction_type_key}, Actual: ${actualLandmarkInteractionType}`);
                                }
                                if (rule.requires_landmark_interaction_type_key && rule.requires_landmark_interaction_type_key === actualLandmarkInteractionType) {
                                    let actionName = (rule.action_name_template || "Use {artifact_name} on {target_name}")
                                        .replace("{artifact_name}", item.name)
                                        .replace("{target_name}", targetName);

                                    let argsForAction = {};
                                    if (rule.passes_target_env_object_id_as_param && selectedLandmarkVisConfig.targetable_as_env_object_id) {
                                        argsForAction[rule.passes_target_env_object_id_as_param] = selectedLandmarkVisConfig.targetable_as_env_object_id;
                                    }

                                    const actionParams = { type: 'action', params: { artifactId: item.id, args: argsForAction }, name: actionName };
                                    availablePointerLockActions.push(actionParams);
                                    const button = document.createElement('button'); button.innerHTML = actionName;
                                    button.onclick = () => socket.emit('performAction', { artifactId: item.id, args: argsForAction });
                                    actionButtons.appendChild(button);
                                }
                            });
                        }
                    });
                }
            }

            if (inventory) {
                inventory.forEach(item => {
                    const itemInteractionRules = item.properties?.client_interaction_rules;
                    if (itemInteractionRules && Array.isArray(itemInteractionRules)) {
                        itemInteractionRules.forEach(rule => {
                            if (rule.is_general_use) {
                                let actionName = (rule.action_name_template || "Use {artifact_name}").replace("{artifact_name}", item.name);
                                const actionParams = { type: 'action', params: { artifactId: item.id, args: {} }, name: actionName };
                                if (!availablePointerLockActions.some(a => a.name === actionParams.name && a.params.artifactId === item.id)) {
                                     availablePointerLockActions.push(actionParams);
                                }
                                const buttonExists = Array.from(actionButtons.children).some(btn => btn.textContent.startsWith(actionName));
                                if(!buttonExists) {
                                    const button = document.createElement('button');
                                    button.innerHTML = `${actionName} <span class="desc">${item.description.substring(0,30) || ''}...</span>`;
                                    button.onclick = () => socket.emit('performAction', { artifactId: item.id, args: {} });
                                    actionButtons.appendChild(button);
                                }
                            }
                        });
                    }
                });
            }

            if (actionButtons.children.length === 0) {
                actionButtons.innerHTML = `<p>${lastSelectedTargetLandmarkKey && landmarksInLocation[lastSelectedTargetLandmarkKey] ? 'No specific actions for ' + (landmarksInLocation[lastSelectedTargetLandmarkKey]?.name || 'selected target') : 'Look around or check inventory.'}</p>`;
            }
            if (availablePointerLockActions.length > 0 && (selectedPointerLockActionIndex === -1 || selectedPointerLockActionIndex >= availablePointerLockActions.length)) {
                selectedPointerLockActionIndex = 0;
            } else if (availablePointerLockActions.length === 0) {
                selectedPointerLockActionIndex = -1;
            }
            updatePointerLockHUD();
        }


        socket.on('connect', () => { addLogMessage('Connected to Orb Oracle!', 'success'); addDebugMessage(`SID: ${socket.id}`); clientSideLastLocationId = null; if (!scene) { initThree(); } });
        socket.on('disconnect', () => { addLogMessage('Disconnected from Oracle.', 'error'); if(usingDesktopControls && document.pointerLockElement) document.exitPointerLock(); });
        socket.on('assignSoulId', (id) => { playerSoulId = id; addDebugMessage(`Soul ID: ${playerSoulId.substring(0,8)}`); socket.emit('requestState'); });

        socket.on('gameStateUpdate', (state) => {
            if (state.error){ addLogMessage(`Server Error: ${state.error}`, 'error'); return; }
            const oldTargetKey = lastSelectedTargetLandmarkKey;
            updateStatus(state);
            updateLog(state.worldLog);
            updateContextualActionsDisplay();
        });

        socket.on('actionResult', (result) => {
            addDebugMessage(`ActRes: ${result.success}, ${result.message ? result.message.substring(0,30) : 'No message'}`);
            addLogMessage(result.message || (result.success ? "Action successful." : "Action failed."), result.success ? 'success' : (result.event ? 'event' : 'error'));
            if (result.success && result.event === "PROMPT_USER_FOR_TOOL_DESCRIPTION") {
                const displayMessage = result.display_message || "The Orb of Ingenuity awaits your command...";
                addLogMessage(displayMessage, 'event');
                let wasPointerLocked = false;
                if (usingDesktopControls && document.pointerLockElement === canvas) { document.exitPointerLock(); wasPointerLocked = true; }
                setTimeout(() => {
                    const userDescription = prompt("Describe the new power for the Orb (e.g., 'Create a temporary light bridge to the keyhole platform'):");
                    if (userDescription && userDescription.trim() !== "") {
                        socket.emit('submitToolDescription', { description: userDescription.trim(), catalyst_artifact_id: result.prompt_for_tool_artifact_id });
                    } else { addLogMessage("Orb command whisper faded.", 'info'); }
                    if (wasPointerLocked && usingDesktopControls) { setTimeout(() => { if(!document.pointerLockElement) canvas.requestPointerLock().catch(err => console.error("Re-lock failed", err)); }, 500); }
                }, 100);
            }
        });
        socket.on('debugInfo', (message) => { addDebugMessage(message); });

        addLogMessage('Reaching out to the ether...');
    </script>
</body>
</html>
