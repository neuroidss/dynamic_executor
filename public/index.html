<!DOCTYPE html>
 <html>
 <head>
     <title>Infinite MMORPG - Orb of Ingenuity Demo</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
     <style>
         body { font-family: sans-serif; display: flex; flex-direction: column; height: 100vh; margin: 0; background-color: #111; color: #eee; overflow: hidden; font-size: 16px; }
         #game-container { position: relative; flex-grow: 1; width: 100%; height: 100%; display: flex; flex-direction: column; }
         #threejs-canvas { display: block; width: 100%; flex-grow: 1; } /* Canvas takes remaining space */
         .ui-overlay { position: absolute; left: 0; right: 0; background-color: rgba(0,0,0,0.6); padding: 5px; box-sizing: border-box; z-index: 10;}
         #log-area { top: 0; height: 25%; overflow-y: scroll; font-size: 0.8em; border-bottom: 1px solid #444;}
         #log-area p { margin: 2px 0; }
         #status-area { top: 25%; height: 20%; overflow-y: auto; font-size: 0.8em; border-top: 1px solid #444; padding: 8px;}
         #action-area { bottom: 0; height: 30%; overflow-y: auto; border-top: 1px solid #444;}
         #action-buttons button { display: block; width: 95%; margin: 5px auto; padding: 10px 10px; font-size: 0.9em; cursor: pointer; background-color: #3a5a97; color: white; border: 1px solid #5c7abd; border-radius: 4px; text-align: left; }
         #action-buttons button:hover { background-color: #4a6ab7; }
         #action-buttons button .desc { font-size: 0.7em; color: #ccc; display: block; margin-top: 3px;}
         #debug-area { position: fixed; bottom: 31%; right: 5px; background: rgba(0,0,0,0.7); color: lime; font-family: monospace; font-size: 0.6em; max-height: 80px; width:120px; overflow-y: scroll; padding: 3px; opacity: 0.8; z-index: 100; border: 1px solid lime;}
         h3 {margin-top: 0; margin-bottom: 3px; text-align: center; border-bottom: 1px solid #555; padding-bottom: 3px; font-size: 1em;}
         #joystick-area { position: absolute; bottom: 35%; left: 10px; width: 100px; height: 100px; opacity: 0.5; z-index: 20;}


         @media (max-width: 768px) { /* Tablet and Mobile */
            body { font-size: 14px; }
            #log-area { height: 20%; font-size: 0.75em;}
            #status-area { top: 20%; height: 15%; font-size: 0.75em; }
            #action-area { height: 25%; font-size: 0.8em; } /* Make action area slightly bigger for taps */
            #action-buttons button { padding: 12px 8px; font-size: 0.85em; }
            #action-buttons button .desc { font-size: 0.65em; }
            #debug-area { max-height: 60px; font-size: 0.5em; width: 100px; bottom: 26%;}
            h3 { font-size: 0.9em; }
            #joystick-area { width: 80px; height: 80px; bottom: 28%;}
         }
          @media (orientation: landscape) and (max-height: 450px) { /* Small landscape phones */
            #log-area { height: 25%; }
            #status-area { display: none; } /* Hide status on very small landscape to give space to actions/log */
            #action-area { height: 35%; }
            #joystick-area { bottom: 10px; left: 10px; width: 70px; height: 70px;}
            #debug-area { bottom: 10px; }
          }

     </style>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
     <script src="https://cdn.socket.io/4.8.1/socket.io.min.js" integrity="sha384-mkQ3/7FUtcGyoppY6bz/PORYoGqOl7/aSUMn2ymDOJcapfS6PHqxhRTMh1RR0Q6+" crossorigin="anonymous"></script>
     <script src="https://yoannmoinet.github.io/nipplejs/javascripts/nipplejs.js"></script>
 </head>
 <body>
     <div id="game-container">
         <canvas id="threejs-canvas"></canvas>
         <div id="log-area" class="ui-overlay">
             <h3>World Log</h3>
             <div id="log-content"></div>
         </div>
         <div id="status-area" class="ui-overlay">
              Loading...
         </div>
         <div id="action-area" class="ui-overlay">
             <h3>Inventory Actions</h3>
             <div id="action-buttons"></div>
         </div>
         <div id="joystick-area"></div>
     </div>
      <div id="debug-area">
          <div id="debug-content"></div>
      </div>

     <script>
         const socket = io();

         const logContent = document.getElementById('log-content');
         const logArea = document.getElementById('log-area');
         const statusArea = document.getElementById('status-area');
         const actionButtons = document.getElementById('action-buttons');
         const debugContent = document.getElementById('debug-content');
         const canvas = document.getElementById('threejs-canvas');

         let playerSoulId = null;
         let currentGameState = {};

         let scene, camera, renderer, playerAvatar;
         const landmarkObjects = {};
         const temporary3DObjects = {};
         let mainGroundPlane, vaultPlatformPlayerSide, vaultPlatformKeyholeSide; 

         const locationCenterPositions = {
             trial_chamber: new THREE.Vector3(0,0,0),
             vault_approach: new THREE.Vector3(10,0,0),
             "LIMBO_VOID": new THREE.Vector3(0, -50, -100),
             null: new THREE.Vector3(0,-50,-100), 
             undefined: new THREE.Vector3(0,-50,-100) 
         };
         const landmarkPositions = { 
             trial_chamber: {
                 flame_pedestal_loc: new THREE.Vector3(2, 0, -2),
                 water_pedestal_loc: new THREE.Vector3(0, 0, -3),
                 wind_pedestal_loc: new THREE.Vector3(-2, 0, -2),
                 sealed_door_exit: new THREE.Vector3(0, 0.5, -5)
             },
             vault_approach: {
                 keyhole_platform_exit: new THREE.Vector3(0, 0, -4),
                 vault_door_main: new THREE.Vector3(0, 1, -6)
             }
         };

         let isPointerDragging = false;
         let pointerDownTime = 0;
         let dragThreshold = 5; 
         let initialPointerPosition = {x:0, y:0};
         let currentPointerPosition = { x: 0, y: 0 };
         let isPointerDownOnCanvas = false;

         let raycaster = new THREE.Raycaster();
         let tapCoordinates = new THREE.Vector2();
         let highlightedObject = null;
         let lastSelectedTargetId = null;

         let joystickMoveVector = new THREE.Vector2(0,0);
         const playerMoveSpeed = 2.5; 
         let lastFrameTime = performance.now();
         
         let clientSideLastLocationId = null;


         function initThree() {
             scene = new THREE.Scene();
             scene.background = new THREE.Color(0x282c34);

             camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
             camera.position.set(0, 2, 5);

             renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
             renderer.setSize(window.innerWidth, window.innerHeight);

             const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
             scene.add(ambientLight);
             const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
             directionalLight.position.set(5, 10, 7);
             scene.add(directionalLight);

             const playerGeometry = new THREE.BoxGeometry(0.5, 1, 0.5);
             const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x00dd00 });
             playerAvatar = new THREE.Mesh(playerGeometry, playerMaterial);
             playerAvatar.position.y = 0.5;
             scene.add(playerAvatar);
             
             const groundGeometry = new THREE.PlaneGeometry(20, 20);
             const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, side: THREE.DoubleSide });
             mainGroundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
             mainGroundPlane.rotation.x = -Math.PI / 2;
             mainGroundPlane.name = "mainGroundPlane";
             scene.add(mainGroundPlane);
             mainGroundPlane.visible = false;

            const platGeo = new THREE.BoxGeometry(5, 0.2, 4);
            const platMat = new THREE.MeshStandardMaterial({ color: 0x5a5a5a });
            vaultPlatformPlayerSide = new THREE.Mesh(platGeo, platMat);
            vaultPlatformPlayerSide.name = "vaultPlatformPlayerSide";
            scene.add(vaultPlatformPlayerSide);
            vaultPlatformPlayerSide.visible = false;

            const keyholePlatGeo = new THREE.BoxGeometry(3, 0.2, 3);
            vaultPlatformKeyholeSide = new THREE.Mesh(keyholePlatGeo, platMat);
            vaultPlatformKeyholeSide.name = "vaultPlatformKeyholeSide";
            scene.add(vaultPlatformKeyholeSide);
            vaultPlatformKeyholeSide.visible = false;

             canvas.addEventListener('pointerdown', onPointerDownCanvas, false);
             canvas.addEventListener('pointermove', onPointerMoveCanvas, false);
             canvas.addEventListener('pointerup', onPointerUpCanvas, false);
             canvas.addEventListener('pointerout', onPointerUpCanvas, false); 
             canvas.addEventListener('wheel', onWheelCanvas, { passive: false }); 

             setupJoystick();
             animate();
             window.addEventListener('resize', onWindowResize, false);
         }

         function onWindowResize() {
             camera.aspect = window.innerWidth / window.innerHeight;
             camera.updateProjectionMatrix();
             renderer.setSize(window.innerWidth, window.innerHeight);
         }

        function onPointerDownCanvas(event) {
            if (event.target !== canvas) return;
            isPointerDownOnCanvas = true;
            isPointerDragging = false;
            pointerDownTime = performance.now();
            currentPointerPosition.x = event.clientX || (event.touches && event.touches[0].clientX);
            currentPointerPosition.y = event.clientY || (event.touches && event.touches[0].clientY);
            initialPointerPosition.x = currentPointerPosition.x;
            initialPointerPosition.y = currentPointerPosition.y;
        }

        function onPointerMoveCanvas(event) {
            if (!isPointerDownOnCanvas) return;
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);

            const deltaX = clientX - currentPointerPosition.x;
            const deltaY = clientY - currentPointerPosition.y;

            if (Math.abs(deltaX) > dragThreshold || Math.abs(deltaY) > dragThreshold) {
                isPointerDragging = true;
            }

            if (isPointerDragging) { 
                const rotationSpeed = 0.004;
                playerAvatar.rotation.y -= deltaX * rotationSpeed;
                camera.rotation.x -= deltaY * rotationSpeed * 0.5; 
                camera.rotation.x = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, camera.rotation.x)); 
            }
            currentPointerPosition.x = clientX;
            currentPointerPosition.y = clientY;
        }

        function onPointerUpCanvas(event) {
            if (!isPointerDownOnCanvas) return;
            const upTime = performance.now();
            const timeDelta = upTime - pointerDownTime;
            const distMoved = Math.sqrt(Math.pow(currentPointerPosition.x - initialPointerPosition.x, 2) + Math.pow(currentPointerPosition.y - initialPointerPosition.y, 2));

            if (!isPointerDragging && timeDelta < 300 && distMoved < 10) { 
                handleCanvasTap(event);
            }
            isPointerDownOnCanvas = false;
            isPointerDragging = false;
        }
        
        function onWheelCanvas(event) {
            event.preventDefault(); 
            const zoomSpeed = 0.01;
            camera.position.z += event.deltaY * zoomSpeed;
            camera.position.z = Math.max(2, Math.min(camera.position.z, 10)); 
        }

         function setupJoystick() {
            const options = {
                zone: document.getElementById('joystick-area'),
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'rgba(128,128,128,0.8)',
                size: Math.min(100, window.innerWidth * 0.2) 
            };
            const joyManager = nipplejs.create(options);
            joyManager.on('move', function (evt, data) {
                if (data.vector) joystickMoveVector.set(data.vector.x, data.vector.y);
            });
            joyManager.on('end', function () {
                joystickMoveVector.set(0,0);
            });
        }

         function animate() {
            requestAnimationFrame(animate);
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastFrameTime) / 1000.0;
            lastFrameTime = currentTime;

            if (playerAvatar && joystickMoveVector.lengthSq() > 0) {
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerAvatar.quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(playerAvatar.quaternion);
                
                let moveDirection = new THREE.Vector3();
                moveDirection.addScaledVector(forward, joystickMoveVector.y * -1); 
                moveDirection.addScaledVector(right, joystickMoveVector.x);
                moveDirection.normalize();

                playerAvatar.position.addScaledVector(moveDirection, playerMoveSpeed * deltaTime);
                playerAvatar.position.y = 0.5; 
            }

            if (playerAvatar) {
                const cameraOffset = new THREE.Vector3(0, 2.5, 3.5); 
                const targetCameraPosition = playerAvatar.position.clone().add(cameraOffset.applyQuaternion(playerAvatar.quaternion));
                camera.position.lerp(targetCameraPosition, 0.15);
                camera.lookAt(playerAvatar.position.clone().add(new THREE.Vector3(0,0.5,0))); 
            }
            renderer.render(scene, camera);
         }

         function addLogMessage(message, type = 'info') {
             const p = document.createElement('p');
             p.textContent = message;
             if (type === 'error') p.style.color = '#ff8c8c';
             if (type === 'success') p.style.color = '#8cff8c';
             if (type === 'event') { p.style.color = '#8cb8ff'; p.style.fontWeight = 'bold';}
             logContent.appendChild(p);
             setTimeout(() => { logArea.scrollTop = logArea.scrollHeight; }, 0);
         }
         function addDebugMessage(message) {
             const d = document.createElement('div');
             d.textContent = message;
             debugContent.appendChild(d);
             debugContent.scrollTop = debugContent.scrollHeight;
         }
        
        function setupLocationVisuals(locationId) {
            const locCenter = locationCenterPositions[locationId] || locationCenterPositions['undefined'] || new THREE.Vector3(0,0,0);
            
            mainGroundPlane.visible = false;
            vaultPlatformPlayerSide.visible = false;
            vaultPlatformKeyholeSide.visible = false;

            if (locationId === 'trial_chamber') {
                mainGroundPlane.visible = true;
                mainGroundPlane.position.copy(locCenter);
            } else if (locationId === 'vault_approach') {
                const currentLocLandmarkRelPositions = landmarkPositions[locationId] || {};
                const keyholeRelPos = currentLocLandmarkRelPositions['keyhole_platform_exit'] || new THREE.Vector3(0, 0, -4);
                const keyholeAbsPos = keyholeRelPos.clone().add(locCenter);

                vaultPlatformPlayerSide.position.set(locCenter.x, locCenter.y - 0.1, locCenter.z + 2); 
                vaultPlatformPlayerSide.visible = true;

                vaultPlatformKeyholeSide.position.set(keyholeAbsPos.x, keyholeAbsPos.y - 0.1, keyholeAbsPos.z);
                vaultPlatformKeyholeSide.visible = true;
            } else { 
                mainGroundPlane.visible = true; 
                mainGroundPlane.position.copy(locCenter);
            }
        }

        function updateLandmarks3D(locationId, landmarksData, envObjectsInLocation, allPuzzleStates) {
            for (const key in landmarkObjects) {
                scene.remove(landmarkObjects[key]); delete landmarkObjects[key];
            }
            if (!landmarksData || !locationId) return;

            const locCenter = locationCenterPositions[locationId] || locationCenterPositions['undefined'] || new THREE.Vector3(0,0,0);
            const currentLocLandmarkRelPositions = landmarkPositions[locationId] || {};

            for (const [landmarkKey, landmarkName] of Object.entries(landmarksData)) {
                const relPos = currentLocLandmarkRelPositions[landmarkKey] || new THREE.Vector3(Math.random()*4-2, 0.25, Math.random()*4-2);
                const absPos = relPos.clone().add(locCenter);
                
                const landmarkGeo = new THREE.SphereGeometry(0.2, 16, 16);
                let landmarkMatColor = 0xaaaaaa;

                let correspondingEnvObject = null;
                if (envObjectsInLocation) {
                    if (landmarkKey === 'flame_pedestal_loc') correspondingEnvObject = envObjectsInLocation.find(obj => obj.id === 'pedestal_fire');
                    else if (landmarkKey === 'water_pedestal_loc') correspondingEnvObject = envObjectsInLocation.find(obj => obj.id === 'pedestal_water');
                    else if (landmarkKey === 'wind_pedestal_loc') correspondingEnvObject = envObjectsInLocation.find(obj => obj.id === 'pedestal_wind');
                    else if (landmarkKey === 'vault_door_main') correspondingEnvObject = envObjectsInLocation.find(obj => obj.id === 'vault_keyhole');
                }
                
                if (correspondingEnvObject) {
                    if (correspondingEnvObject.type === 'elemental_pedestal') {
                        landmarkMatColor = correspondingEnvObject.details && correspondingEnvObject.details.is_active ? 0x00ff00 : 0xccaa88;
                    } else if (correspondingEnvObject.id === 'vault_keyhole') {
                        const vaultPuzzle = allPuzzleStates ? allPuzzleStates['unreachable_vault'] : null;
                        if ((correspondingEnvObject.details && correspondingEnvObject.details.is_unlocked) || (vaultPuzzle && vaultPuzzle.is_open)) {
                            landmarkMatColor = 0x7777ff;
                        } else {
                            landmarkMatColor = 0x333388;
                        }
                    }
                } else if (landmarkKey.includes("pedestal")) landmarkMatColor = 0xccaa88;
                else if (landmarkKey.includes("door") || landmarkKey.includes("exit")) {
                    if (landmarkKey === 'sealed_door_exit' && locationId === 'trial_chamber') {
                        const trialPuzzle = allPuzzleStates ? allPuzzleStates['elemental_trial'] : null;
                        landmarkMatColor = (trialPuzzle && trialPuzzle.is_complete) ? 0x77cc77 : 0x8888cc;
                    } else landmarkMatColor = 0x8888cc;
                }

                const landmarkMat = new THREE.MeshStandardMaterial({ color: landmarkMatColor });
                const landmarkMesh = new THREE.Mesh(landmarkGeo, landmarkMat);
                landmarkMesh.position.copy(absPos);
                landmarkMesh.userData = { id: landmarkKey, name: landmarkName, type: 'landmark', isInteractable: true }; 
                scene.add(landmarkMesh);
                landmarkObjects[landmarkKey] = landmarkMesh;
            }
        }
        
        function updateTemporaryObjects3D(tempObjectsData, currentLocationId) {
            for (const objId in temporary3DObjects) {
                if (!tempObjectsData || !tempObjectsData.find(obj => obj.id === objId && obj.location_id === currentLocationId)) {
                    scene.remove(temporary3DObjects[objId]); delete temporary3DObjects[objId];
                }
            }
            if (!tempObjectsData || !currentLocationId) return;

            const locCenter = locationCenterPositions[currentLocationId] || locationCenterPositions['undefined'] || new THREE.Vector3(0,0,0);
            const currentLocLandmarkRelPositions = landmarkPositions[currentLocationId] || {};

            tempObjectsData.forEach(obj => {
                if (obj.location_id !== currentLocationId || temporary3DObjects[obj.id]) return; 

                if (obj.type === 'light_bridge') {
                    let fromPos = playerAvatar.position.clone(); 
                    const toLandmarkKey = obj.to;
                    let toPosRel = currentLocLandmarkRelPositions[toLandmarkKey] || new THREE.Vector3(0, 0.1, -5); 
                    let toPosAbs = toPosRel.clone().add(locCenter);

                    const distance = fromPos.distanceTo(toPosAbs);
                    const bridgeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
                    const bridgeGeometry = new THREE.BoxGeometry(0.3, 0.1, distance); 
                    const bridgeMesh = new THREE.Mesh(bridgeGeometry, bridgeMaterial);

                    bridgeMesh.position.copy(fromPos).lerp(toPosAbs, 0.5); 
                    bridgeMesh.lookAt(toPosAbs);
                    bridgeMesh.position.y = fromPos.y - 0.4; 

                    scene.add(bridgeMesh);
                    temporary3DObjects[obj.id] = bridgeMesh;
                    
                    setTimeout(() => {
                        if (temporary3DObjects[obj.id]) {
                            scene.remove(temporary3DObjects[obj.id]); delete temporary3DObjects[obj.id];
                        }
                    }, obj.duration * 1000);
                }
            });
        }

         function updateStatus(state) {
              if (!state || !state.playerSoul ) {
                  statusArea.innerHTML = "Waiting for server data..."; return;
              }
              currentGameState = state;

              let currentLocationDisplay = state.currentLocation || { name: "The Void", description: "Loading...", landmarks: {}, exits: {}};
              if (state.playerSoul.locationId === "LIMBO_VOID" || state.playerSoul.locationId === null || !state.currentLocation) {
                  currentLocationDisplay = { id: state.playerSoul.locationId, name: "The Void", description: "Drifting in an unformed expanse...", exits: {}, landmarks: {}, temporary_notes: "None"};
              }

              let statusHTML = `
                  <strong>${state.playerSoul.name}</strong> (ID: ${state.playerSoul.id.substring(0,8)})<br>
                  Location: <strong>${currentLocationDisplay.name}</strong> (ID: ${currentLocationDisplay.id})<br>
                  <em>${currentLocationDisplay.description}</em><br>
                  Exits: ${Object.entries(currentLocationDisplay.exits || {}).map(([dir, loc_id]) => `${dir}: ${loc_id}`).join(', ') || 'None'} <br>
                  Landmarks: ${currentLocationDisplay.landmarks ? Object.keys(currentLocationDisplay.landmarks).join(', ') : 'None'} <br>
                  Temporary Notes: ${currentLocationDisplay.temporary_notes || 'None'} <br>
                  Inventory: ${state.inventory ? state.inventory.map(a => a.name).join(', ') : 'Empty'}
              `;
              statusArea.innerHTML = statusHTML;

              if (playerAvatar) {
                  const newLocationId = state.playerSoul.locationId || "LIMBO_VOID";
                  
                  if (newLocationId !== clientSideLastLocationId) { 
                      let targetPlayerPos = locationCenterPositions[newLocationId];
                      if(!targetPlayerPos) {
                          console.warn(`No locationCenterPosition for ${newLocationId}, defaulting.`);
                          targetPlayerPos = locationCenterPositions["undefined"] || new THREE.Vector3(0,0,0);
                      }
                      
                      playerAvatar.position.copy(targetPlayerPos); 
                      playerAvatar.position.y = 0.5; 

                      clientSideLastLocationId = newLocationId; 
                      setupLocationVisuals(newLocationId); 
                  }
                  updateLandmarks3D(newLocationId, currentLocationDisplay.landmarks, state.environmentObjectsInLocation, state.allPuzzleStates);
                  updateTemporaryObjects3D(state.activeTemporaryObjects, newLocationId);
              }
         }
         function updateLog(logEntries) {
              if (!logEntries) return;
              logContent.innerHTML = '';
              logEntries.forEach(msg => addLogMessage(msg));
         }
         function renderActions(actions) {
             actionButtons.innerHTML = '';
             if (!actions || actions.length === 0) {
                 actionButtons.innerHTML = '<p>No actions available.</p>'; return;
             }
             actions.forEach(actionArtifact => {
                 const button = document.createElement('button');
                 button.dataset.artifactId = actionArtifact.id;
                 button.innerHTML = `${actionArtifact.name} <span class="desc">${actionArtifact.description || `(Use ${actionArtifact.name})`}</span>`;
                 button.onclick = () => {
                     addDebugMessage(`Clicked action: ${actionArtifact.name} (ID: ${actionArtifact.id}, Func: ${actionArtifact.toolName || 'N/A'})`);
                     let args = {};
                     if (actionArtifact.toolName === 'df_interact_with_pedestal') {
                         if (lastSelectedTargetId) {
                            args.target_pedestal_id = lastSelectedTargetId;
                         } else {
                            addLogMessage('Please tap on a pedestal in the 3D world first.', 'error'); return;
                         }
                     }
                     socket.emit('performAction', { artifactId: actionArtifact.id, args: args });
                     if (highlightedObject) highlightedObject.material.emissive.setHex(0x000000);
                     highlightedObject = null; lastSelectedTargetId = null;
                 };
                 actionButtons.appendChild(button);
             });
         }

        function handleCanvasTap(event) {
            tapCoordinates.x = (event.clientX / window.innerWidth) * 2 - 1;
            tapCoordinates.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(tapCoordinates, camera);

            const interactables = Object.values(landmarkObjects).filter(obj => obj.visible && obj.userData.isInteractable);
            const intersects = raycaster.intersectObjects(interactables, false);

            if (highlightedObject) {
                highlightedObject.material.emissive.setHex(0x000000); highlightedObject = null;
            }
            lastSelectedTargetId = null;

            if (intersects.length > 0) {
                const clickedObj = intersects[0].object;
                if (clickedObj.userData && clickedObj.userData.id) {
                    highlightedObject = clickedObj;
                    highlightedObject.material.emissive.setHex(0xffff00); 
                    lastSelectedTargetId = clickedObj.userData.id;
                    addLogMessage(`Targeted: ${clickedObj.userData.name || clickedObj.userData.id}`, 'info');
                }
            }
        }

         socket.on('connect', () => {
             addLogMessage('Connected!', 'success'); addDebugMessage(`Socket ID: ${socket.id}`);
             clientSideLastLocationId = null; // Reset on connect
             initThree(); 
         });
         socket.on('disconnect', () => { addLogMessage('Disconnected.', 'error'); });
         socket.on('assignSoulId', (id) => {
              playerSoulId = id; addDebugMessage(`Player Soul ID: ${playerSoulId}`);
              socket.emit('requestState'); 
          });
         socket.on('gameStateUpdate', (state) => {
              addDebugMessage('Received gameStateUpdate');
              if (state.error){ addLogMessage(`Server Error: ${state.error}`, 'error'); return; }
             updateStatus(state); updateLog(state.worldLog);
         });
         socket.on('availableActions', (actions) => {
             addDebugMessage(`Received ${actions ? actions.length : 0} actions.`);
             renderActions(actions);
         });
         socket.on('actionResult', (result) => {
              addDebugMessage(`Action Result: Success=${result.success}, Msg=${result.message}`);
              addLogMessage(result.message, result.success ? 'success' : (result.message.startsWith("EVENT:") ? 'event' : 'error'));
              if (result.success && result.event === "PROMPT_USER_FOR_TOOL_DESCRIPTION") { 
                  addLogMessage("The Orb of Ingenuity hums...", 'event');
                  const userDescription = prompt("Describe the new power for the Orb (e.g., 'Create a temporary light bridge to the keyhole platform'):");
                  if (userDescription && userDescription.trim() !== "") {
                      socket.emit('submitToolDescription', {
                          description: userDescription.trim(),
                          catalyst_artifact_id: result.prompt_for_tool_artifact_id 
                      });
                  } else { addLogMessage("Orb command cancelled.", 'info'); }
              }
              socket.emit('requestState'); 
         });
         socket.on('debugInfo', (message) => { addDebugMessage(message); });
         socket.on('requestState', () => { 
                addDebugMessage('Server requested state refresh.');
               if(playerSoulId) socket.emit('requestState');
           });
         addLogMessage('Attempting to connect...');
     </script>
 </body>
 </html>
